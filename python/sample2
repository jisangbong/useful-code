import numpy as np
import pandas as pd
import sys


# grade_group = {'g1': 2, 'g2': 3, 'g3': 4}
# df_rank = pd.DataFrame.from_dict(dict_map, orient='index').reset_index().rename(columns={'index': 'model'})

# rank = np.array([[dict_map[main][sub] for sub in sub_group] for main in main_group], dtype=float)
# print(rank)
# flat_ranks = pd.Series(rank.flatten()).rank(method='dense').to_numpy().reshape(rank.shape)
# print(flat_ranks)
# dict_map = {
#     main: {
#         sub: flat_ranks[i, j]
#         for j, sub in enumerate(sub_group)
#     }
#     for i, main in enumerate(main_group)
# }
# print(dict_map)

print('python:', sys.version)
print('numpy:', np.__version__)
print('pandas:', pd.__version__)


dict_map_result = {'m1': {'g1': 0, 'g2': 0, 'g3': 0}, 'm2': {'g1': 0, 'g2': 0, 'g3': 0}}
dict_map_l = {'m1': {'g1': 5, 'g2': 4, 'g3': 1}, 'm2': {'g1': 11, 'g2': 12, 'g3': 1}}
dict_map_r = {'m1': {'g1': 3, 'g2': 10, 'g3': 1}, 'm2': {'g1': 21, 'g2': 22, 'g3': 1}}
main_group = ['m1', 'm2']
sub_group = ['g1', 'g2', 'g3']
grade_group = {'g1': 2, 'g2': 3, 'g3': 4}

arr_map = np.array([[dict_map_result[m][g] for g in sub_group] for m in main_group], dtype=float)
arr_l = np.array([[dict_map_l[m][g] for g in sub_group] for m in main_group], dtype=float)
arr_r = np.array([[dict_map_r[m][g] for g in sub_group] for m in main_group], dtype=float)
grades = np.array([grade_group[g] for g in sub_group])  # shape: (3,)

# Compute level values
level_l = np.minimum((arr_l + 0.1) ** 1.5, 22)
level_r = np.minimum((arr_r + 0.1) ** 1.5, 22)

# Compute result according to condition
result = np.select(
    [
        level_l > level_r,
        level_l < level_r,
        level_l == level_r
    ],
    [
        np.minimum(np.minimum(level_r * 3, level_l * 2), 49),
        np.minimum(np.minimum(level_l * 3, level_r * 2), 49),
        np.minimum(np.minimum(level_l * 3, level_r * 3), 49)
    ],
    default=0
) * grades  # shape: (2, 3)

print(result)

rank = pd.Series(result.flatten()).rank(method='dense').to_numpy().reshape(result.shape)
print(rank)

dict_map_result = {
    main: {
        sub: rank[i, j]
        for j, sub in enumerate(sub_group)
    }
    for i, main in enumerate(main_group)
}
print(dict_map_result)









dict_map = {'m1':
                {'g1': 1
                , 'g2': 11
                , 'g3': 21}
            , 'm2':
                {'g1': 2
                , 'g2': 12
                , 'g3': 22}}

main_group = ['m1', 'm2']
sub_group = ['g1', 'g2', 'g3']
grade_group = {'g1': 2, 'g2': 3, 'g3': 4}


for main in main_group:
    for sub in sub_group:
        level_l = (dict_map_l[main][sub] + 0.1) ** 1.5
        level_r = (dict_map_l[main][sub] + 0.1) ** 1.5
        grade = grade_group[sub]

        if level_l > level_r:
            result = min(level_r*3, level_l*2) * grade
        elif level_l > level_r:
            result = min(level_l*3, level_r*2) * grade
        else:
            result = min(level_l*3, level_r*3) * grade
        dict_map[main][sub] = grade

print(dict_map)
df_rank = pd.DataFrame.from_dict(dict_map, orient='index').reset_index().rename(columns={'index': 'model'})

df_rank = df_rank.melt(id_vars=['model'], value_vars=['g1', 'g2', 'g3'],
                 var_name='parameter', value_name='value')

df_rank['rank'] = df_rank['value'].rank(method='dense')

df_rank = df_rank.pivot(index='model', columns='parameter', values='rank').add_suffix('_rank').reset_index()

print(df_rank)


















import numpy as np
import pandas as pd

# Original dicts
dict_map_l = {'m1': {'g1': 3, 'g2': 4, 'g3': 1}, 'm2': {'g1': 11, 'g2': 12, 'g3': 1}}
dict_map_r = {'m1': {'g1': 1, 'g2': 2, 'g3': 1}, 'm2': {'g1': 21, 'g2': 22, 'g3': 1}}
grade_group = {'g1': 2, 'g2': 3, 'g3': 4}

main_group = ['m1', 'm2']
sub_group = ['g1', 'g2', 'g3']

# Convert dicts to arrays
arr_l = np.array([[dict_map_l[m][g] for g in sub_group] for m in main_group], dtype=float)
arr_r = np.array([[dict_map_r[m][g] for g in sub_group] for m in main_group], dtype=float)
grades = np.array([grade_group[g] for g in sub_group])  # shape: (3,)

print(arr_l)
print(arr_r)
print(grades)
# Compute level values
level_l = (arr_l + 0.1) ** 1.5
level_r = (arr_r + 0.1) ** 1.5

# Broadcast grades
grade_b = grades[np.newaxis, :]  # shape: (1, 3)
print(grade_b)
# Define conditions
cond_gt = level_l > level_r
cond_lt = level_l < level_r
cond_eq = level_l == level_r

# Compute result according to condition
result = np.select(
    [cond_gt, cond_lt, cond_eq],
    [
        np.minimum(level_r * 3, level_l * 2),
        np.minimum(level_l * 3, level_r * 2),
        np.minimum(level_l * 3, level_r * 3),
    ],
    default=0
) * grade_b  # shape: (2, 3)

# Create DataFrame
df_values = pd.DataFrame(result, columns=sub_group)
df_values.insert(0, 'model', main_group)
print(df_values)
# Melt and rank
df_melted = df_values.melt(id_vars='model', var_name='parameter', value_name='value')
df_melted['rank'] = df_melted['value'].rank(method='dense')

# Pivot back to rank table
df_rank = df_melted.pivot(index='model', columns='parameter', values='rank').add_suffix('_rank').reset_index()

# Optional: Show value + rank together
# df_final = df_values.merge(df_rank, on='model')

print(df_rank)













dict_map_l = {'m1':
                {'g1': 3
                , 'g2': 4
                , 'g3': 1}
            , 'm2':
                {'g1': 11
                , 'g2': 12
                , 'g3': 1}}

dict_map_r = {'m1':
                {'g1': 1
                , 'g2': 2
                , 'g3': 1}
            , 'm2':
                {'g1': 21
                , 'g2': 22
                , 'g3': 1}}


dict_map = {'m1':
                {'g1': 1
                , 'g2': 11
                , 'g3': 21}
            , 'm2':
                {'g1': 2
                , 'g2': 12
                , 'g3': 22}}

main_group = ['m1', 'm2']
sub_group = ['g1', 'g2', 'g3']
grade_group = {'g1': 2, 'g2': 3, 'g3': 4}


for main in main_group:
    for sub in sub_group:
        level_l = (dict_map_l[main][sub] + 0.1) ** 1.5
        level_r = (dict_map_r[main][sub] + 0.1) ** 1.5
        grade = grade_group[sub]

        if level_l > level_r:
            result = min(level_r*3, level_l*2) * grade
        elif level_l > level_r:
            result = min(level_l*3, level_r*2) * grade
        else:
            result = min(level_l*3, level_r*3) * grade
        dict_map[main][sub] = result


df_rank = pd.DataFrame.from_dict(dict_map, orient='index').reset_index().rename(columns={'index': 'model'})

df_rank = df_rank.melt(id_vars=['model'], value_vars=['g1', 'g2', 'g3'],
                 var_name='parameter', value_name='value')

df_rank['rank'] = df_rank['value'].rank(method='dense')

df_rank = df_rank.pivot(index='model', columns='parameter', values='rank').reset_index()

for main in main_group:

    for sub in sub_group:
        dict_map[main][sub] = df_rank[df_rank['model']==main][sub].iloc[0]

print(dict_map)

dict_map = {
    main: {
        sub: df_rank[df_rank['model']==main][sub].iloc[0]
        for sub in sub_group
    }
    for main in main_group
}
print(dict_map)











import numpy as np
import pandas as pd

# Initial data
dict_map_l = {'m1': {'g1': 3, 'g2': 4, 'g3': 1}, 'm2': {'g1': 11, 'g2': 12, 'g3': 1}}
dict_map_r = {'m1': {'g1': 1, 'g2': 2, 'g3': 1}, 'm2': {'g1': 21, 'g2': 22, 'g3': 1}}
main_group = ['m1', 'm2']
sub_group = ['g1', 'g2', 'g3']
grade_group = {'g1': 2, 'g2': 3, 'g3': 4}

# Convert to NumPy arrays
l_array = np.array([[dict_map_l[main][sub] for sub in sub_group] for main in main_group], dtype=float)
r_array = np.array([[dict_map_r[main][sub] for sub in sub_group] for main in main_group], dtype=float)
grades = np.array([grade_group[sub] for sub in sub_group], dtype=float)

# Calculate levels
level_l = (l_array + 0.1) ** 1.5
level_r = (r_array + 0.1) ** 1.5

# Apply logic using vectorized NumPy conditions
greater = level_l > level_r
equal = np.isclose(level_l, level_r)

# Initialize result array
result = np.zeros_like(level_l)

# Case 1: level_l > level_r
result[greater] = np.minimum(level_r[greater] * 3, level_l[greater] * 2)

# Case 2: level_r > level_l
result[~greater & ~equal] = np.minimum(level_l[~greater & ~equal] * 3, level_r[~greater & ~equal] * 2)

# Case 3: level_l == level_r
result[equal] = np.minimum(level_l[equal] * 3, level_r[equal] * 3)

# Apply grades (broadcasting)
result *= grades

# Rank across entire result array
flat_ranks = pd.Series(result.flatten()).rank(method='dense').to_numpy().reshape(result.shape)

# Build updated dict_map with ranks
dict_map_ranked = {
    main: {
        sub: flat_ranks[i, j]
        for j, sub in enumerate(sub_group)
    }
    for i, main in enumerate(main_group)
}

# Optional: Convert to DataFrame for preview
df_result = pd.DataFrame(flat_ranks, index=main_group, columns=sub_group).reset_index().rename(columns={'index': 'model'})
print(df_result)
print(dict_map_ranked)





















dict_map = {'m1': {'g1': 0, 'g2': 0, 'g3': 0}, 'm2': {'g1': 0, 'g2': 0, 'g3': 0}}
dict_map_l = {'m1': {'g1': 5, 'g2': 4, 'g3': 1}, 'm2': {'g1': 11, 'g2': 12, 'g3': 1}}
dict_map_r = {'m1': {'g1': 3, 'g2': 10, 'g3': 1}, 'm2': {'g1': 21, 'g2': 22, 'g3': 1}}
main_group = ['m1', 'm2']
sub_group = ['g1', 'g2', 'g3']
grade_group = {'g1': 2, 'g2': 3, 'g3': 4}


for main in main_group:
    for sub in sub_group:
        level_l = min((dict_map_l[main][sub] + 0.1) ** 1.5, 22)
        level_r = min((dict_map_r[main][sub] + 0.1) ** 1.5, 22)
        grade = grade_group[sub]

        if level_l > level_r:
            result = min(min(level_r*3, level_l*2) * grade, 49)
        elif level_l > level_r:
            result = min(min(level_l*3, level_r*2) * grade, 49)
        else:
            result = min(min(level_l*3, level_r*3) * grade, 49)
        dict_map[main][sub] = result

rank = np.array([[dict_map[main][sub] for sub in sub_group] for main in main_group], dtype=float)
print(rank)
flat_ranks = pd.Series(rank.flatten()).rank(method='dense').to_numpy().reshape(rank.shape)
print(flat_ranks)
dict_map = {
    main: {
        sub: flat_ranks[i, j]
        for j, sub in enumerate(sub_group)
    }
    for i, main in enumerate(main_group)
}
print(dict_map)







import numpy as np
import pandas as pd

# Initial dictionaries
dict_map = {'m1': {'g1': 0, 'g2': 0, 'g3': 0}, 'm2': {'g1': 0, 'g2': 0, 'g3': 0}}
dict_map_l = {'m1': {'g1': 5, 'g2': 4, 'g3': 1}, 'm2': {'g1': 11, 'g2': 12, 'g3': 1}}
dict_map_r = {'m1': {'g1': 3, 'g2': 10, 'g3': 1}, 'm2': {'g1': 21, 'g2': 22, 'g3': 1}}

main_group = ['m1', 'm2']
sub_group = ['g1', 'g2', 'g3']
grade_group = {'g1': 2, 'g2': 3, 'g3': 4}

# Precompute grades as a NumPy array
grades = np.array([grade_group[sub] for sub in sub_group])

# Convert dict_map_l and dict_map_r to NumPy arrays
arr_l = np.array([[dict_map_l[main][sub] for sub in sub_group] for main in main_group], dtype=float)
arr_r = np.array([[dict_map_r[main][sub] for sub in sub_group] for main in main_group], dtype=float)

# Apply transformation (level = min((value + 0.1)^1.5, 22))
level_l = np.minimum((arr_l + 0.1) ** 1.5, 22)
level_r = np.minimum((arr_r + 0.1) ** 1.5, 22)

# Compute result based on comparison logic
min_l3_r2 = np.minimum(level_l * 3, level_r * 2)
min_r3_l2 = np.minimum(level_r * 3, level_l * 2)
equal_lr = np.minimum(level_l * 3, level_r * 3)

# Conditions
gt_mask = level_l > level_r
lt_mask = level_r > level_l
eq_mask = ~gt_mask & ~lt_mask  # exactly equal

# Initialize result array
result = np.zeros_like(level_l)

# Apply conditions and multiply by grade, then clip to 49
result[gt_mask] = min_l3_r2[gt_mask]
result[lt_mask] = min_r3_l2[lt_mask]
result[eq_mask] = equal_lr[eq_mask]
result = np.minimum(result * grades, 49)

# Rank the result values globally (flatten, rank, reshape)
flat_ranks = pd.Series(result.flatten()).rank(method='dense').to_numpy().reshape(result.shape)

# Construct ranked dict_map
dict_map_ranked = {
    main: {
        sub: flat_ranks[i, j]
        for j, sub in enumerate(sub_group)
    }
    for i, main in enumerate(main_group)
}

# If you want to override the original dict_map with ranks
dict_map = dict_map_ranked

# Outputs
print("Rank matrix:\n", result)
print("Flat ranks:\n", flat_ranks)
print("dict_map with ranks:\n", dict_map)


import pandas as pd
import numpy as np

df = pd.DataFrame({
    'A': ['x', 'x', 'y', 'y'],
    'B': [1, np.nan, 5, np.nan],
    'C': [2, 3, np.nan, 8],
    'D': [np.nan, 4, 6, 7]
})

df[['B', 'C', 'D']] = df.groupby('A')[['B', 'C', 'D']].transform(
    lambda x: x.fillna(x.max().max() + 1)
)

print(df)


def fill_groupwise_max_plus_one(group):
    row_max = group[['B', 'C', 'D']].max(axis=1)
    group_max = row_max.max()
    return group[['B', 'C', 'D']].applymap(
        lambda x: group_max + 1 if pd.isna(x) else x
    ).assign(A=group['A'].values)

df = df.groupby('A', group_keys=False).apply(fill_groupwise_max_plus_one)

