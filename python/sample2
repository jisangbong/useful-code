

CREATE OR REPLACE PROCEDURE load_performance IS
    -- Cursor for departments
    CURSOR dept_cur IS
        SELECT deptno
        FROM dept;

    -- Cursor for employees in a department
    CURSOR emp_cur(p_deptno dept.deptno%TYPE) IS
        SELECT empno
        FROM emp
        WHERE deptno = p_deptno;

    -- Cursor for sales by employee, grouped by date
    CURSOR sales_cur(p_empno emp.empno%TYPE) IS
        SELECT sale_date,
               SUM(sales_amount) AS total_sales
        FROM sales
        WHERE empno = p_empno
        GROUP BY sale_date;
BEGIN
    -- Loop through departments
    FOR d IN dept_cur LOOP
        -- Loop through employees in each department
        FOR e IN emp_cur(d.deptno) LOOP
            -- Loop through sales totals for each employee
            FOR s IN sales_cur(e.empno) LOOP
                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (d.deptno, e.empno, s.sale_date, s.total_sales);
            END LOOP;
        END LOOP;
    END LOOP;

    COMMIT;
END load_performance;




CREATE OR REPLACE PROCEDURE update_emp_performance_bulk IS
    -- Record type for employee updates
    TYPE emp_perf_rec IS RECORD (
        empno      emp.empno%TYPE,
        total_perf NUMBER
    );

    -- Table type for bulk processing
    TYPE emp_perf_tab IS TABLE OF emp_perf_rec;
    l_emp_perf emp_perf_tab;

    -- Cursor for batching
    CURSOR c_perf IS
        SELECT empno, SUM(total_sales) AS total_perf
        FROM performance
        GROUP BY empno;

    l_limit CONSTANT PLS_INTEGER := 10000;  -- chunk size
    l_count PLS_INTEGER := 0;
BEGIN
    OPEN c_perf;
    LOOP
        FETCH c_perf BULK COLLECT INTO l_emp_perf LIMIT l_limit;
        EXIT WHEN l_emp_perf.COUNT = 0;

        -- Bulk update EMP using FORALL
        FORALL i IN 1 .. l_emp_perf.COUNT
            UPDATE emp
            SET performance = l_emp_perf(i).total_perf
            WHERE empno = l_emp_perf(i).empno;

        COMMIT;  -- commit after each chunk
        l_count := l_count + l_emp_perf.COUNT;
        DBMS_OUTPUT.PUT_LINE('Updated ' || l_count || ' rows so far...');
    END LOOP;

    CLOSE c_perf;
    DBMS_OUTPUT.PUT_LINE('All EMP rows updated successfully.');
END update_emp_performance_bulk;
/


CREATE OR REPLACE PROCEDURE load_performance IS
BEGIN
    -- Loop over departments
    FOR d IN (SELECT deptno FROM dept) LOOP
        -- Loop over employees in each department
        FOR e IN (SELECT empno FROM emp WHERE deptno = d.deptno) LOOP
            -- Loop over sales totals by date for each employee
            FOR s IN (SELECT sale_date,
                             SUM(sales_amount) AS total_sales
                      FROM sales
                      WHERE empno = e.empno
                      GROUP BY sale_date) LOOP

                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (d.deptno, e.empno, s.sale_date, s.total_sales);

            END LOOP;
        END LOOP;
    END LOOP;

    COMMIT;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    c_dept   SYS_REFCURSOR;
    c_emp    SYS_REFCURSOR;
    c_sales  SYS_REFCURSOR;

    v_deptno dept.deptno%TYPE;
    v_empno  emp.empno%TYPE;
    v_date   sales.sale_date%TYPE;
    v_total  NUMBER;
BEGIN
    OPEN c_dept FOR SELECT deptno FROM dept;
    LOOP
        FETCH c_dept INTO v_deptno; EXIT WHEN c_dept%NOTFOUND;

        OPEN c_emp FOR SELECT empno FROM emp WHERE deptno = v_deptno;
        LOOP
            FETCH c_emp INTO v_empno; EXIT WHEN c_emp%NOTFOUND;

            OPEN c_sales FOR
                SELECT sale_date, SUM(sales_amount)
                FROM sales
                WHERE empno = v_empno
                GROUP BY sale_date;

            LOOP
                FETCH c_sales INTO v_date, v_total; EXIT WHEN c_sales%NOTFOUND;

                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (v_deptno, v_empno, v_date, v_total);

            END LOOP;
            CLOSE c_sales;
        END LOOP;
        CLOSE c_emp;
    END LOOP;
    CLOSE c_dept;

    COMMIT;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    v_count PLS_INTEGER := 0;
BEGIN
    -- Loop over departments
    FOR d IN (SELECT deptno FROM dept) LOOP
        -- Loop over employees in each department
        FOR e IN (SELECT empno FROM emp WHERE deptno = d.deptno) LOOP
            -- Loop over sales totals by date for each employee
            FOR s IN (SELECT sale_date,
                             SUM(sales_amount) AS total_sales
                      FROM sales
                      WHERE empno = e.empno
                      GROUP BY sale_date) LOOP

                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (d.deptno, e.empno, s.sale_date, s.total_sales);

                v_count := v_count + 1;

                -- Commit every 10,000 rows
                IF MOD(v_count, 10000) = 0 THEN
                    COMMIT;
                END IF;

            END LOOP;
        END LOOP;
    END LOOP;

    -- Final commit for leftovers
    COMMIT;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    TYPE perf_tab IS TABLE OF performance%ROWTYPE;
    l_data perf_tab;
BEGIN
    -- Fetch everything in one SELECT
    SELECT e.deptno, s.empno, s.sale_date, SUM(s.sales_amount)
    BULK COLLECT INTO l_data
    FROM emp e
         JOIN sales s ON e.empno = s.empno
         JOIN dept d  ON e.deptno = d.deptno
    GROUP BY e.deptno, s.empno, s.sale_date;

    -- Insert in chunks of 10,000
    FOR i IN 1 .. CEIL(l_data.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_data.COUNT)
            INSERT INTO performance VALUES l_data(j);
        COMMIT;
    END LOOP;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    TYPE perf_tab IS TABLE OF performance%ROWTYPE;
    l_data perf_tab;
BEGIN
    -- Collect everything with one query
    SELECT e.deptno, s.empno, s.sale_date, SUM(s.sales_amount)
    BULK COLLECT INTO l_data
    FROM   emp e
           JOIN sales s ON e.empno = s.empno
           JOIN dept d  ON e.deptno = d.deptno
    GROUP  BY e.deptno, s.empno, s.sale_date;

    -- Insert in chunks of 10,000
    FOR i IN 1 .. CEIL(l_data.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_data.COUNT)
            INSERT INTO performance VALUES l_data(j);
        COMMIT;
    END LOOP;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    -- Custom record type matching the 4 columns we insert
    TYPE perf_rec IS RECORD (
        deptno      performance.deptno%TYPE,
        empno       performance.empno%TYPE,
        sale_date   performance.sale_date%TYPE,
        total_sales performance.total_sales%TYPE
    );

    -- Table type for bulk processing
    TYPE perf_tab IS TABLE OF perf_rec;
    l_data perf_tab;
BEGIN
    -- Bulk collect from sales aggregation
    SELECT e.deptno,
           s.empno,
           s.sale_date,
           SUM(s.sales_amount)
    BULK COLLECT INTO l_data
    FROM   emp e
           JOIN sales s ON e.empno = s.empno
           JOIN dept d  ON e.deptno = d.deptno
    GROUP  BY e.deptno, s.empno, s.sale_date;

    -- Insert in chunks of 10,000 rows
    FOR i IN 1 .. CEIL(l_data.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_data.COUNT)
            INSERT INTO performance (deptno, empno, sale_date, total_sales)
            VALUES (l_data(j).deptno,
                    l_data(j).empno,
                    l_data(j).sale_date,
                    l_data(j).total_sales);

        COMMIT;
    END LOOP;
END load_performance;




CREATE OR REPLACE PROCEDURE load_and_update_performance IS
    -- Type for bulk collecting performance inserts
    TYPE perf_rec IS RECORD (
        deptno      performance.deptno%TYPE,
        empno       performance.empno%TYPE,
        sale_date   performance.sale_date%TYPE,
        total_sales performance.total_sales%TYPE
    );

    TYPE perf_tab IS TABLE OF perf_rec;
    l_perf perf_tab;

    -- Type for updating EMP.performance
    TYPE emp_perf_rec IS RECORD (
        empno       emp.empno%TYPE,
        total_perf  NUMBER
    );

    TYPE emp_perf_tab IS TABLE OF emp_perf_rec;
    l_emp_perf emp_perf_tab;
BEGIN
    -- 1️⃣ Bulk collect aggregated sales into collection
    SELECT e.deptno,
           s.empno,
           s.sale_date,
           SUM(s.sales_amount) AS total_sales
    BULK COLLECT INTO l_perf
    FROM   emp e
           JOIN sales s ON e.empno = s.empno
           JOIN dept d  ON e.deptno = d.deptno
    GROUP  BY e.deptno, s.empno, s.sale_date;

    -- 2️⃣ Insert into PERFORMANCE in chunks of 10,000 rows
    FOR i IN 1 .. CEIL(l_perf.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_perf.COUNT)
            INSERT INTO performance (deptno, empno, sale_date, total_sales)
            VALUES (l_perf(j).deptno,
                    l_perf(j).empno,
                    l_perf(j).sale_date,
                    l_perf(j).total_sales);

        COMMIT; -- commit after each chunk
    END LOOP;

    -- 3️⃣ Collect total performance per employee for EMP update
    SELECT empno, SUM(total_sales) AS total_perf
    BULK COLLECT INTO l_emp_perf
    FROM performance
    GROUP BY empno;

    -- 4️⃣ Bulk update EMP.performance
    FORALL i IN 1 .. l_emp_perf.COUNT
        UPDATE emp
        SET performance = l_emp_perf(i).total_perf
        WHERE empno = l_emp_perf(i).empno;

    COMMIT; -- final commit after updating EMP
END load_and_update_performance;



INSERT /*+ APPEND */ INTO performance (deptno, empno, sale_date, total_sales)
SELECT e.deptno,
       s.empno,
       s.sale_date,
       SUM(s.sales_amount)
FROM   emp e
       JOIN sales s ON e.empno = s.empno
GROUP  BY e.deptno, s.empno, s.sale_date;




DECLARE
    CURSOR c_data IS
        SELECT e.deptno, s.empno, s.sale_date, SUM(s.sales_amount) AS total_sales
        FROM emp e
             JOIN sales s ON e.empno = s.empno
        GROUP BY e.deptno, s.empno, s.sale_date;
    TYPE perf_tab IS TABLE OF performance%ROWTYPE;
    l_data perf_tab;
BEGIN
    OPEN c_data;
    LOOP
        FETCH c_data BULK COLLECT INTO l_data LIMIT 10000;  -- fetch 10k at a time
        EXIT WHEN l_data.COUNT = 0;

        FORALL i IN 1 .. l_data.COUNT
            INSERT INTO performance (deptno, empno, sale_date, total_sales)
            VALUES (l_data(i).deptno, l_data(i).empno, l_data(i).sale_date, l_data(i).total_sales);

        COMMIT;  -- commit after each chunk
    END LOOP;
    CLOSE c_data;
END;


UPDATE (
    SELECT t1.column1, t1.column2, t2.new_column1, t2.new_column2
    FROM your_table t1
    JOIN another_table t2
      ON t1.id = t2.id
     AND t2.some_condition
) v
SET v.column1 = v.new_column1,
    v.column2 = v.new_column2;




























WITH
-- 1) combos
combos AS (
    SELECT DISTINCT location_id, item_id, shop_id
    FROM (
        SELECT location_id, item_id, shop_id FROM inventory_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM delivery_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM sales_table
    )
),
-- 2) calendar dates
dates AS (
    SELECT date_seq, date_key, day_of_week, date_week, year_of_day
    FROM date_table
    WHERE date_seq BETWEEN DATE '2025-07-31' AND DATE '2025-10-31'
),
-- 3) full calendar per combo
calendar AS (
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           d.date_seq,
           d.date_key,
           d.day_of_week,
           TRUNC(d.date_seq, 'IW') AS week_monday
    FROM combos c
    CROSS JOIN dates d
),
-- 4) aggregates on source tables
inv_agg AS (
    SELECT location_id, item_id, shop_id, inventory_date, SUM(inventory_qty) AS inventory_qty
    FROM inventory_table
    GROUP BY location_id, item_id, shop_id, inventory_date
),
del_agg AS (
    SELECT location_id, item_id, shop_id, delivery_date, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id, shop_id, delivery_date
),
sal_agg AS (
    SELECT location_id, item_id, shop_id, sales_date, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id, shop_id, sales_date
),
-- 5) daily rows w/ running inventory (inventory = running sum of inv + del - sales)
daily_data AS (
    SELECT
        cal.location_id,
        cal.item_id,
        cal.shop_id,
        cal.date_seq,
        cal.date_key,
        cal.day_of_week,
        -- running balance (end-of-day inventory)
        SUM(NVL(inv.inventory_qty,0) + NVL(del.delivery_qty,0) - NVL(sal.sales_qty,0))
          OVER (PARTITION BY cal.location_id, cal.item_id, cal.shop_id
                ORDER BY cal.date_seq
                ROWS UNBOUNDED PRECEDING) AS inventory_qty,
        NVL(del.delivery_qty,0) AS delivery_qty,
        NVL(sal.sales_qty,0)    AS sales_qty,
        (NVL(del.delivery_qty,0) - NVL(sal.sales_qty,0)) AS day_result,
        cal.week_monday
    FROM calendar cal
    LEFT JOIN inv_agg inv
      ON cal.location_id = inv.location_id
     AND cal.item_id     = inv.item_id
     AND cal.shop_id     = inv.shop_id
     AND cal.date_seq    = inv.inventory_date
    LEFT JOIN del_agg del
      ON cal.location_id = del.location_id
     AND cal.item_id     = del.item_id
     AND cal.shop_id     = del.shop_id
     AND cal.date_seq    = del.delivery_date
    LEFT JOIN sal_agg sal
      ON cal.location_id = sal.location_id
     AND cal.item_id     = sal.item_id
     AND cal.shop_id     = sal.shop_id
     AND cal.date_seq    = sal.sales_date
),
-- 6) weekly totals (one row per week per combo). inventory = Sunday snapshot (end-of-week),
-- flows = weekly sums; weekdays_with_data used to decide whether to emit weekly total.
weekly_agg AS (
    SELECT
        location_id,
        item_id,
        shop_id,
        week_monday,
        week_monday + 6 AS week_sunday,
        -- Sunday snapshot for inventory (end-of-week)
        MAX(CASE WHEN date_seq = week_monday + 6 THEN inventory_qty END) AS week_inventory,
        -- weekly flows
        SUM(delivery_qty) AS week_delivery,
        SUM(sales_qty)    AS week_sales,
        -- how many Mon-Sat rows had any data (useful to decide whether to show weekly total)
        SUM(CASE WHEN (date_seq - week_monday + 1) BETWEEN 1 AND 6
                 AND (NVL(inventory_qty,0) <> 0 OR NVL(delivery_qty,0) <> 0 OR NVL(sales_qty,0) <> 0)
             THEN 1 ELSE 0 END) AS weekdays_with_data
    FROM daily_data
    GROUP BY location_id, item_id, shop_id, week_monday
),
-- 7) compute forward-4-week averages only on weekly_agg using ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING.
--    This ensures the window moves by weekly rows, not by date range (avoids the daily-row problem).
weekly_with_avg AS (
    SELECT
        w.*,
        AVG(week_inventory) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS avg_inv_next4,
        AVG(week_delivery) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS avg_del_next4,
        AVG(week_sales) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS avg_sales_next4,
        COUNT(*) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS weeks_ahead_count
    FROM weekly_agg w
),
-- 8) combined: daily rows + weekly rows (weekly rows pulled from weekly_with_avg; we only emit weekly rows where weekdays_with_data > 0)
combined AS (
    -- daily detail rows (no 4-week averages)
    SELECT
        location_id,
        item_id,
        shop_id,
        date_seq,
        date_key,
        day_of_week,
        inventory_qty,
        delivery_qty,
        sales_qty,
        day_result,
        NULL AS weekly_total_flag,
        week_monday,
        (date_seq - week_monday + 1) AS day_pos,
        NULL         AS inventory_qty_4_weeks,
        NULL         AS delivery_qty_4_weeks,
        NULL         AS sales_qty_4_weeks
    FROM daily_data
    UNION ALL
    -- weekly total rows, with forward-4-week averages populated only when at least 4 weeks exist ahead
    SELECT
        w.location_id,
        w.item_id,
        w.shop_id,
        w.week_sunday   AS date_seq,
        TO_CHAR(w.week_sunday,'YYYYMMDD') AS date_key,
        'Weekly Total'  AS day_of_week,
        w.week_inventory AS inventory_qty,
        w.week_delivery  AS delivery_qty,
        w.week_sales     AS sales_qty,
        NULL             AS day_result,
        'Y'              AS weekly_total_flag,
        w.week_monday,
        8                AS day_pos,
        CASE WHEN w.weeks_ahead_count >= 4 THEN w.avg_inv_next4 ELSE NULL END AS inventory_qty_4_weeks,
        CASE WHEN w.weeks_ahead_count >= 4 THEN w.avg_del_next4 ELSE NULL END AS delivery_qty_4_weeks,
        CASE WHEN w.weeks_ahead_count >= 4 THEN w.avg_sales_next4 ELSE NULL END AS sales_qty_4_weeks
    FROM weekly_with_avg w
    WHERE w.weekdays_with_data > 0
)
-- final output ordered so weekly total appears after Sunday
SELECT *
FROM combined
ORDER BY location_id, item_id, shop_id, week_monday, day_pos, date_seq;












WITH
-- 1) combos of shop/location/item
combos AS (
    SELECT DISTINCT location_id, item_id, shop_id
    FROM (
        SELECT location_id, item_id, shop_id FROM delivery_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM sales_table
    )
),
-- 2) calendar dates
dates AS (
    SELECT date_seq
    FROM date_table
    WHERE date_seq BETWEEN DATE '2025-08-01' AND DATE '2025-09-01'
),
-- 3) full calendar per combo
calendar AS (
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           d.date_seq
    FROM combos c
    CROSS JOIN dates d
),
-- 4) aggregate deliveries
del_agg AS (
    SELECT location_id, item_id, shop_id, delivery_date, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id, shop_id, delivery_date
),
-- 5) aggregate sales
sal_agg AS (
    SELECT location_id, item_id, shop_id, sales_date, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id, shop_id, sales_date
),
-- 6) daily data with NVL
daily_data AS (
    SELECT
        cal.location_id,
        cal.item_id,
        cal.shop_id,
        cal.date_seq,
        NVL(del.delivery_qty, 0) AS delivery_qty,
        NVL(sal.sales_qty, 0)    AS sales_qty
    FROM calendar cal
    LEFT JOIN del_agg del
      ON cal.location_id = del.location_id
     AND cal.item_id     = del.item_id
     AND cal.shop_id     = del.shop_id
     AND cal.date_seq    = del.delivery_date
    LEFT JOIN sal_agg sal
      ON cal.location_id = sal.location_id
     AND cal.item_id     = sal.item_id
     AND cal.shop_id     = sal.shop_id
     AND cal.date_seq    = sal.sales_date
),
-- 7) rolling 28-day averages
rolling AS (
    SELECT
        d.location_id,
        d.item_id,
        d.shop_id,
        d.date_seq,
        d.delivery_qty,
        d.sales_qty,
        SUM(d.delivery_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_delivery_28d,
        SUM(d.sales_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_sales_28d,
        COUNT(*) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS cnt_28d
    FROM daily_data d
),
-- 8) average past 28 days
avg_data AS (
    SELECT
        r.*,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_delivery_28d / r.cnt_28d ELSE 0 END AS avg_delivery_28d,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_sales_28d / r.cnt_28d ELSE 0 END AS avg_sales_28d
    FROM rolling r
),
-- 9) total per location/item/date
totals AS (
    SELECT
        a.date_seq,
        a.location_id,
        a.item_id,
        SUM(a.delivery_qty) AS total_delivery_qty,
        SUM(a.avg_delivery_28d) AS total_avg_delivery_28d,
        SUM(a.avg_sales_28d) AS total_avg_sales_28d
    FROM avg_data a
    GROUP BY a.date_seq, a.location_id, a.item_id
),
-- 10) join to compute proportions and initial fixed allocation
proportions AS (
    SELECT
        a.location_id,
        a.item_id,
        a.shop_id,
        a.date_seq,
        a.delivery_qty,
        a.sales_qty,
        a.avg_delivery_28d,
        a.avg_sales_28d,
        t.total_delivery_qty,
        t.total_avg_delivery_28d,
        t.total_avg_sales_28d,
        CASE WHEN t.total_avg_delivery_28d = 0 THEN 0
             ELSE round(a.avg_delivery_28d / t.total_avg_delivery_28d, 4) END AS avg_delivery_28d_proportion,
        CASE WHEN t.total_avg_sales_28d = 0 THEN 0
             ELSE round(a.avg_sales_28d / t.total_avg_sales_28d, 4) END AS avg_sales_28d_proportion,
        ROUND(t.total_delivery_qty *
             CASE WHEN t.total_avg_delivery_28d = 0 THEN 1.0 / COUNT(*) OVER (PARTITION BY a.location_id, a.item_id, a.date_seq)
                  ELSE a.avg_delivery_28d / t.total_avg_delivery_28d END
        ) AS fixed_delivery_qty_base
    FROM avg_data a
    JOIN totals t
      ON a.location_id = t.location_id
     AND a.item_id     = t.item_id
     AND a.date_seq    = t.date_seq
),
-- 11) adjust rounding differences
adjusted AS (
    SELECT
        p.*,
        SUM(p.fixed_delivery_qty_base) OVER (PARTITION BY p.location_id, p.item_id, p.date_seq) AS sum_fixed_base,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion DESC) AS rn_desc,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion ASC) AS rn_asc
    FROM proportions p
)
-- 12) final fixed delivery qty with adjustment
SELECT
    a.location_id,
    a.item_id,
    a.shop_id,
    a.date_seq,
    a.delivery_qty,
    a.sales_qty,
    a.avg_delivery_28d,
    a.avg_sales_28d,
    a.avg_delivery_28d_proportion,
    a.avg_sales_28d_proportion,
    a.total_delivery_qty,
    a.sum_fixed_base,
    a.fixed_delivery_qty_base,
CASE
    WHEN a.total_delivery_qty = a.sum_fixed_base THEN a.fixed_delivery_qty_base
    WHEN a.total_delivery_qty > a.sum_fixed_base AND a.rn_desc = 1 THEN a.fixed_delivery_qty_base + (a.total_delivery_qty - a.sum_fixed_base)
    WHEN a.total_delivery_qty < a.sum_fixed_base AND a.rn_asc = 1 THEN a.fixed_delivery_qty_base - (a.sum_fixed_base - a.total_delivery_qty)
    ELSE a.fixed_delivery_qty_base
END AS fixed_delivery_qty
FROM adjusted a
ORDER BY a.location_id, a.item_id, a.shop_id, a.date_seq;






WITH
-- 1) combos of shop/location/item
combos AS (
    SELECT DISTINCT location_id, item_id, shop_id
    FROM (
        SELECT location_id, item_id, shop_id FROM delivery_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM sales_table
    ) t
),
-- 2) calendar dates
dates AS (
    SELECT date_seq
    FROM date_table
    WHERE date_seq BETWEEN DATE '2025-08-01' AND DATE '2025-09-01'
),
-- 3) full calendar per combo
calendar AS (
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           d.date_seq
    FROM combos c
    CROSS JOIN dates d
),
-- 4) aggregate deliveries
del_agg AS (
    SELECT location_id, item_id, shop_id, delivery_date, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id, shop_id, delivery_date
),
-- 5) aggregate sales
sal_agg AS (
    SELECT location_id, item_id, shop_id, sales_date, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id, shop_id, sales_date
),
-- 6) daily data with NVL
daily_data AS (
    SELECT
        cal.location_id,
        cal.item_id,
        cal.shop_id,
        cal.date_seq,
        NVL(del.delivery_qty, 0) AS delivery_qty,
        NVL(sal.sales_qty, 0) AS sales_qty
    FROM calendar cal
    LEFT JOIN del_agg del
      ON cal.location_id = del.location_id
     AND cal.item_id = del.item_id
     AND cal.shop_id = del.shop_id
     AND cal.date_seq = del.delivery_date
    LEFT JOIN sal_agg sal
      ON cal.location_id = sal.location_id
     AND cal.item_id = sal.item_id
     AND cal.shop_id = sal.shop_id
     AND cal.date_seq = sal.sales_date
),
-- 7) rolling 28-day sums and counts (efficient analytic calculation)
rolling AS (
    SELECT
        d.location_id,
        d.item_id,
        d.shop_id,
        d.date_seq,
        d.delivery_qty,
        d.sales_qty,
        SUM(d.delivery_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_delivery_28d,
        SUM(d.sales_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_sales_28d,
        COUNT(*) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS cnt_28d
    FROM daily_data d
),
-- 8) average past 28 days
avg_data AS (
    SELECT
        r.location_id,
        r.item_id,
        r.shop_id,
        r.date_seq,
        r.delivery_qty,
        r.sales_qty,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_delivery_28d / r.cnt_28d ELSE 0 END AS avg_delivery_28d,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_sales_28d / r.cnt_28d ELSE 0 END AS avg_sales_28d
    FROM rolling r
),
-- 9) total per location/item/date
totals AS (
    SELECT
        a.date_seq,
        a.location_id,
        a.item_id,
        SUM(a.delivery_qty) AS total_delivery_qty,
        SUM(a.avg_delivery_28d) AS total_avg_delivery_28d,
        SUM(a.avg_sales_28d) AS total_avg_sales_28d
    FROM avg_data a
    GROUP BY a.date_seq, a.location_id, a.item_id
),
-- 10) join to compute proportions and initial fixed allocation
proportions AS (
    SELECT
        a.location_id,
        a.item_id,
        a.shop_id,
        a.date_seq,
        a.delivery_qty,
        a.sales_qty,
        a.avg_delivery_28d,
        a.avg_sales_28d,
        t.total_delivery_qty,
        t.total_avg_delivery_28d,
        t.total_avg_sales_28d,
        CASE WHEN t.total_avg_delivery_28d = 0 THEN 0
             ELSE round(a.avg_delivery_28d / t.total_avg_delivery_28d, 4) END AS avg_delivery_28d_proportion,
        CASE WHEN t.total_avg_sales_28d = 0 THEN 0
             ELSE round(a.avg_sales_28d / t.total_avg_sales_28d, 4) END AS avg_sales_28d_proportion,
        ROUND(t.total_delivery_qty *
             CASE WHEN t.total_avg_delivery_28d = 0 THEN 1.0 / COUNT(*) OVER (PARTITION BY a.location_id, a.item_id, a.date_seq)
                  ELSE a.avg_delivery_28d / t.total_avg_delivery_28d END
        ) AS fixed_delivery_qty_base
    FROM avg_data a
    JOIN totals t
      ON a.location_id = t.location_id
     AND a.item_id = t.item_id
     AND a.date_seq = t.date_seq
),
-- 11) adjust rounding differences
adjusted AS (
    SELECT
        p.*,
        SUM(p.fixed_delivery_qty_base) OVER (PARTITION BY p.location_id, p.item_id, p.date_seq) AS sum_fixed_base,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion DESC) AS rn_desc,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion ASC) AS rn_asc
    FROM proportions p
)
-- 12) final fixed delivery qty with adjustment
SELECT
    a.location_id,
    a.item_id,
    a.shop_id,
    a.date_seq,
    a.delivery_qty,
    a.sales_qty,
    a.avg_delivery_28d,
    a.avg_sales_28d,
    a.avg_delivery_28d_proportion,
    a.avg_sales_28d_proportion,
    a.total_delivery_qty,
    a.sum_fixed_base,
    a.fixed_delivery_qty_base,
    CASE
        WHEN a.total_delivery_qty = a.sum_fixed_base THEN a.fixed_delivery_qty_base
        WHEN a.total_delivery_qty > a.sum_fixed_base AND a.rn_desc = 1 THEN a.fixed_delivery_qty_base + (a.total_delivery_qty - a.sum_fixed_base)
        WHEN a.total_delivery_qty < a.sum_fixed_base AND a.rn_asc = 1 THEN a.fixed_delivery_qty_base - (a.sum_fixed_base - a.total_delivery_qty)
        ELSE a.fixed_delivery_qty_base
    END AS fixed_delivery_qty
FROM adjusted a
ORDER BY a.location_id, a.item_id, a.shop_id, a.date_seq;























WITH
-- 1) sales per shop on given day
day_sum_result AS (
    SELECT LOCATION_ID, ITEM_ID, SHOP_ID, SUM(SALES_QTY) AS DAY_SUM_QTY
    FROM SALES_TABLE
    WHERE SALES_DATE = DATE '2025-08-08'
      AND ITEM_ID = 'MacBook'
    GROUP BY LOCATION_ID, ITEM_ID, SHOP_ID
),
-- 2) total sales per item/location
shop_sum_result AS (
    SELECT LOCATION_ID, ITEM_ID, SHOP_ID, DAY_SUM_QTY,
           SUM(DAY_SUM_QTY) OVER (PARTITION BY LOCATION_ID, ITEM_ID) AS shop_sum_qty
    FROM day_sum_result
),
-- 3) ratio per shop
shop_ratio AS (
    SELECT a.ITEM_ID, a.SHOP_ID,
           ROUND(SUM(a.DAY_SUM_QTY) / SUM(a.SHOP_SUM_QTY), 4) AS ratio
    FROM shop_sum_result a
    GROUP BY a.ITEM_ID, a.SHOP_ID
),
-- 4) join with deliveries and compute base allocations
base_rows AS (
    SELECT A.LOCATION_ID,
           A.ITEM_ID,
           A.SHOP_ID,
           A.DELIVERY_QTY,
           B.RATIO,
           SUM(A.DELIVERY_QTY) OVER (PARTITION BY A.LOCATION_ID, A.ITEM_ID) AS total_delivery_qty,
           ROUND(SUM(A.DELIVERY_QTY) OVER (PARTITION BY A.LOCATION_ID, A.ITEM_ID) * B.RATIO, 0) AS delivery_ratio_qty
    FROM DELIVERY_TABLE A
    JOIN shop_ratio B
      ON A.SHOP_ID = B.SHOP_ID
    WHERE A.DELIVERY_DATE = DATE '2025-08-08'
      AND A.LOCATION_ID = 'loc01'
),
-- 5) compute total vs sum_base
totals AS (
    SELECT location_id, item_id,
           SUM(delivery_ratio_qty) AS sum_fixed_base,
           MAX(total_delivery_qty)  AS total_delivery_qty
    FROM base_rows
    GROUP BY location_id, item_id
),
-- 6) add row numbers for allocation order
ranked AS (
    SELECT b.location_id,
           b.item_id,
           b.shop_id,
           b.delivery_qty,
           b.ratio,
           b.total_delivery_qty AS base_total_delivery_qty,
           b.delivery_ratio_qty,
           t.sum_fixed_base,
           t.total_delivery_qty AS total_delivery_qty,  -- canonical
           ROW_NUMBER() OVER (PARTITION BY b.location_id, b.item_id ORDER BY b.ratio ASC)  AS rn_asc,
           ROW_NUMBER() OVER (PARTITION BY b.location_id, b.item_id ORDER BY b.ratio DESC) AS rn_desc
    FROM base_rows b
    JOIN totals t
      ON b.location_id = t.location_id
     AND b.item_id     = t.item_id
),
-- 7) recursive redistribution of negative difference (only if sum_fixed_base > total_delivery_qty)
adjust_cte (location_id, item_id, shop_id, rn_asc, delivery_ratio_qty, remaining_diff, fixed_qty) AS (
    -- Anchor: smallest ratio (rn_asc = 1)
    SELECT r.location_id,
           r.item_id,
           r.shop_id,
           r.rn_asc,
           r.delivery_ratio_qty,
           (r.sum_fixed_base - r.total_delivery_qty) AS remaining_diff,
           CASE
             WHEN r.delivery_ratio_qty >= (r.sum_fixed_base - r.total_delivery_qty)
             THEN r.delivery_ratio_qty - (r.sum_fixed_base - r.total_delivery_qty)
             ELSE 0
           END AS fixed_qty
    FROM ranked r
    WHERE r.rn_asc = 1
      AND r.sum_fixed_base > r.total_delivery_qty
    UNION ALL
    -- Recursive: next rows absorb the leftover
    SELECT r.location_id,
           r.item_id,
           r.shop_id,
           r.rn_asc,
           r.delivery_ratio_qty,
           GREATEST(a.remaining_diff - r.delivery_ratio_qty, 0) AS remaining_diff,
           CASE
             WHEN a.remaining_diff <= r.delivery_ratio_qty
             THEN r.delivery_ratio_qty - a.remaining_diff
             ELSE 0
           END AS fixed_qty
    FROM ranked r
    JOIN adjust_cte a
      ON r.location_id = a.location_id
     AND r.item_id     = a.item_id
     AND r.rn_asc      = a.rn_asc + 1
)
-- 8) final result
SELECT r.location_id,
       r.item_id,
       r.shop_id,
       r.delivery_qty,
       r.delivery_ratio_qty,
       r.base_total_delivery_qty,
       r.sum_fixed_base,
       CASE
         -- Case 1: sum_fixed_base > total_delivery_qty → use recursive adjusted qty
         WHEN r.sum_fixed_base > r.total_delivery_qty
         THEN COALESCE(a.fixed_qty, r.delivery_ratio_qty)
         -- Case 2: sum_fixed_base < total_delivery_qty → add difference to highest ratio shop
         WHEN r.sum_fixed_base < r.total_delivery_qty AND r.rn_desc = 1
         THEN r.delivery_ratio_qty + (r.total_delivery_qty - r.sum_fixed_base)
         ELSE r.delivery_ratio_qty
       END AS fixed_delivery_qty
FROM ranked r
LEFT JOIN adjust_cte a
  ON r.location_id = a.location_id
 AND r.item_id     = a.item_id
 AND r.shop_id     = a.shop_id
ORDER BY r.location_id, r.item_id, r.rn_asc;




















WITH
day_sum_result AS (
SELECT
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID,
	SUM(SALES_QTY) AS DAY_SUM_QTY
FROM
	SALES_TABLE
WHERE
	SALES_DATE = DATE '2025-08-08'
	AND ITEM_ID = 'MacBook'
GROUP BY
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID
),
shop_sum_result AS (
SELECT
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID,
	DAY_SUM_QTY,
	SUM(DAY_SUM_QTY) OVER (PARTITION BY LOCATION_ID,
	ITEM_ID) AS shop_sum_qty
FROM
	day_sum_result
ORDER BY
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID
),
shop_ratio AS (
SELECT
	a.ITEM_ID,
	a.SHOP_ID,
	round(sum(a.DAY_SUM_QTY) / sum(a.SHOP_SUM_QTY), 2) AS ratio
FROM
	shop_sum_result a
GROUP BY
	a.ITEM_ID,
	a.SHOP_ID
),
ranked AS (
SELECT
	p.*,
	SUM(p.delivery_ratio_qty + 50) OVER (PARTITION BY p.location_id,
	p.item_id) AS sum_fixed_base,
	ROW_NUMBER() OVER (PARTITION BY p.location_id,
	p.item_id
ORDER BY
	p.RATIO DESC) AS rn_desc,
	ROW_NUMBER() OVER (PARTITION BY p.location_id,
	p.item_id
ORDER BY
	p.RATIO ASC) AS rn_asc
FROM
	(
	SELECT
		A.*,
		B.RATIO,
		sum(A.delivery_qty) OVER (PARTITION BY a.location_id,
		b.item_id) AS total_delivery_qty,
		round(sum(A.delivery_qty) OVER (PARTITION BY a.location_id, b.item_id) * b.RATIO, 0) AS delivery_ratio_qty
	FROM
		DELIVERY_TABLE A,
		shop_ratio B
	WHERE
		A.SHOP_ID = B.SHOP_ID
		AND A.DELIVERY_DATE = DATE '2025-08-08'
		AND A.LOCATION_ID = 'loc01'
) p
),
adjust_cte (location_id,
item_id,
shop_id,
rn_asc,
tag,
SUM_FIXED_BASE,
TOTAL_DELIVERY_QTY,
delivery_ratio_qty,
remaining,
remaining_diff,
fixed_qt) AS (
SELECT
	r.LOCATION_ID,
	r.ITEM_ID,
	r.SHOP_ID,
	r.RN_ASC,
	'a' AS tag,
	r.SUM_FIXED_BASE,
	r.TOTAL_DELIVERY_QTY,
	r.DELIVERY_RATIO_QTY,
	r.remaining_diff AS remaining,
	r.remaining_diff - (DELIVERY_RATIO_QTY - fixed_qty) AS remaining_diff,
	r.fixed_qty
FROM
	(
	SELECT
		r.LOCATION_ID,
		r.ITEM_ID,
		r.SHOP_ID,
		r.RN_ASC,
		'a' AS tag,
		r.SUM_FIXED_BASE,
		r.TOTAL_DELIVERY_QTY,
		r.DELIVERY_RATIO_QTY,
		r.SUM_FIXED_BASE - r.TOTAL_DELIVERY_QTY AS remaining_diff,
		CASE
			WHEN r.DELIVERY_RATIO_QTY >= (r.sum_fixed_base - total_delivery_qty)
     THEN r.DELIVERY_RATIO_QTY - (r.sum_fixed_base - total_delivery_qty)
			ELSE 0
		END AS fixed_qty
	FROM
		ranked r
	WHERE
		r.RN_ASC = 1
		AND r.SUM_FIXED_BASE > r.TOTAL_DELIVERY_QTY
) r
UNION ALL
SELECT
	r.LOCATION_ID,
	r.ITEM_ID,
	r.SHOP_ID,
	r.RN_ASC,
	'b' AS tag,
	r.SUM_FIXED_BASE,
	r.TOTAL_DELIVERY_QTY,
	r.DELIVERY_RATIO_QTY,
	a.remaining,
	greatest (a.REMAINING_DIFF - r.DELIVERY_RATIO_QTY,
	0) AS remaining_diff,
	CASE
		WHEN a.REMAINING_DIFF <= r.DELIVERY_RATIO_QTY
     THEN r.DELIVERY_RATIO_QTY - a.REMAINING_DIFF
		ELSE 0
	END AS fixed_qty
FROM
	ranked r,
	adjust_cte a
WHERE
	r.LOCATION_ID = a.LOCATION_ID
	AND r.ITEM_ID = a.ITEM_ID
	AND r.RN_ASC = a.RN_ASC + 1
)
SELECT
	*
FROM
	adjust_cte
WHERE
	ITEM_ID = 'MacBook'



SELECT A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, A.DATE_SEQ, A.DAY_OF_WEEK,
       A.INVENTORY_QTY, B.DELIVERY_QTY, C.SALES_QTY,
       NVL(B.DELIVERY_QTY, 0) - NVL(C.SALES_QTY, 0) AS DAY_RESULT,
       SUM(NVL(A.INVENTORY_QTY, 0) + NVL(B.DELIVERY_QTY, 0) - NVL(C.SALES_QTY, 0)) OVER (PARTITION BY A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID ORDER BY A.DATE_SEQ) AS INVENTORY
FROM (
      SELECT *
      FROM DATE_TABLE A
           LEFT OUTER JOIN INVENTORY_TABLE B PARTITION BY (B.LOCATION_ID, B.ITEM_ID, B.SHOP_ID)
           ON A.DATE_SEQ = B.INVENTORY_DATE
      WHERE A.DATE_SEQ BETWEEN DATE '2025-07-31' AND DATE '2025-10-31'
      ) A,
      DELIVERY_TABLE B,
      SALES_TABLE C
WHERE A.DATE_SEQ = B.DELIVERY_DATE (+)
AND A.LOCATION_ID = B.LOCATION_ID (+)
AND A.ITEM_ID = B.ITEM_ID (+)
AND A.SHOP_ID = B.SHOP_ID (+)
AND A.DATE_SEQ = C.SALES_DATE (+)
AND A.LOCATION_ID = C.LOCATION_ID (+)
AND A.ITEM_ID = C.ITEM_ID (+)
AND A.SHOP_ID = C.SHOP_ID (+)
ORDER BY A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, A.DATE_SEQ


SELECT A.*, SUM(INVENTORY_QTY) OVER (ORDER BY A.SALES_DATE)
FROM (
SELECT A.INVENTORY_DATE AS SALES_DATE, A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, 0 AS SALES_QTY, 0 AS DELIVERY_QTY, A.INVENTORY_QTY 
FROM INVENTORY_TABLE A
WHERE A.LOCATION_ID = 'loc01'
AND A.ITEM_ID = 'iPhone'
AND A.SHOP_ID = 'Costco'
UNION all
SELECT A.SALES_DATE, A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, A.SALES_QTY, B.DELIVERY_QTY, B.DELIVERY_QTY - A.SALES_QTY AS INVENTORY_QTY
FROM SALES_TABLE A, DELIVERY_TABLE B
WHERE A.LOCATION_ID = B.LOCATION_ID
AND A.ITEM_ID = B.ITEM_ID
AND A.SHOP_ID = B.SHOP_ID
AND A.SALES_DATE = B.DELIVERY_DATE
AND A.LOCATION_ID = 'loc01'
AND A.ITEM_ID = 'iPhone'
AND A.SHOP_ID = 'Costco'
) A
--ORDER BY A.SALES_DATE










WITH inv_cte (
    location_id, item_id, sales_date,
    receipts_qty, sales_qty,
    inventory_qty
) AS (
    -- Anchor: earliest sales_date per item
    SELECT t.location_id,
           t.item_id,
           t.sales_date,
           t.receipts_qty,
           t.sales_qty,
           (0 + t.receipts_qty - t.sales_qty) AS inventory_qty
    FROM inventory_txn t
    WHERE (t.location_id, t.item_id, t.sales_date) IN (
        SELECT location_id, item_id, MIN(sales_date)
        FROM inventory_txn
        GROUP BY location_id, item_id
    )
    UNION ALL
    -- Recursive: next closest sales_date
    SELECT t.location_id,
           t.item_id,
           t.sales_date,
           t.receipts_qty,
           t.sales_qty,
           (a.inventory_qty + t.receipts_qty - t.sales_qty) AS inventory_qty
    FROM inv_cte a
    JOIN inventory_txn t
      ON t.location_id = a.location_id
     AND t.item_id     = a.item_id
     AND t.sales_date = (
            SELECT MIN(s2.sales_date)
            FROM inventory_txn s2
            WHERE s2.location_id = a.location_id
              AND s2.item_id     = a.item_id
              AND s2.sales_date  > a.sales_date
       )
)
SEARCH DEPTH FIRST BY sales_date SET seq_col
CYCLE location_id, item_id, sales_date
    SET cycle_mark TO 'Y' DEFAULT 'N'
SELECT location_id,
       item_id,
       sales_date,
       receipts_qty,
       sales_qty,
       inventory_qty,
       seq_col
FROM inv_cte
WHERE cycle_mark = 'N'
ORDER BY location_id, item_id, sales_date;









WITH inv_cte (
    location_id, item_id, sales_date,
    receipts_qty, sales_qty,
    inventory_qty
) AS (
    -- Anchor: earliest sales_date per item
    SELECT t.location_id,
           t.item_id,
           t.sales_date,
           t.receipts_qty,
           t.sales_qty,
           (0 + t.receipts_qty - t.sales_qty) AS inventory_qty
    FROM inventory_txn t
    WHERE (t.location_id, t.item_id, t.sales_date) IN (
        SELECT location_id, item_id, MIN(sales_date)
        FROM inventory_txn
        GROUP BY location_id, item_id
    )
    UNION ALL
    -- Recursive: next closest sales_date
    SELECT t.location_id,
           t.item_id,
           t.sales_date,
           t.receipts_qty,
           t.sales_qty,
           (a.inventory_qty + t.receipts_qty - t.sales_qty) AS inventory_qty
    FROM inv_cte a
    JOIN inventory_txn t
      ON t.location_id = a.location_id
     AND t.item_id     = a.item_id
     AND t.sales_date = (
            SELECT MIN(s2.sales_date)
            FROM inventory_txn s2
            WHERE s2.location_id = a.location_id
              AND s2.item_id     = a.item_id
              AND s2.sales_date  > a.sales_date
       )
)
SEARCH DEPTH FIRST BY sales_date SET seq_col
CYCLE location_id, item_id, sales_date
    SET cycle_mark TO 'Y' DEFAULT 'N'
SELECT location_id,
       item_id,
       sales_date,
       receipts_qty,
       sales_qty,
       inventory_qty,
       seq_col
FROM inv_cte
WHERE cycle_mark = 'N'
ORDER BY location_id, item_id, sales_date;





WITH combos AS (
  -- distinct combos and their date range (ignore NULL keys)
  SELECT location_id,
         item_id,
         MIN(sales_date) AS min_date,
         MAX(sales_date) AS max_date
  FROM inventory_txn
  WHERE location_id IS NOT NULL
    AND item_id     IS NOT NULL
  GROUP BY location_id, item_id
),
nums AS (
  -- number generator up to the largest span across combos
  SELECT LEVEL AS n
  FROM dual
  CONNECT BY LEVEL <= (
    SELECT NVL(MAX(max_date - min_date + 1), 0) FROM combos
  )
),
calendar AS (
  -- expand each combo into every date from min_date .. max_date
  SELECT c.location_id,
         c.item_id,
         c.min_date + (n.n - 1) AS sales_date
  FROM combos c
  JOIN nums n
    ON n.n <= (c.max_date - c.min_date + 1)
),
base AS (
  -- left-join actual transactions so missing days get zeros
  SELECT cal.location_id,
         cal.item_id,
         cal.sales_date,
         NVL(t.receipts_qty, 0) AS receipts_qty,
         NVL(t.sales_qty,   0) AS sales_qty,
         CASE WHEN t.location_id IS NULL THEN 1 ELSE 0 END AS is_blank
  FROM calendar cal
  LEFT JOIN inventory_txn t
    ON t.location_id = cal.location_id
   AND t.item_id     = cal.item_id
   AND t.sales_date  = cal.sales_date
),
first_day AS (
  -- first calendar date per combo (anchor for recursion)
  SELECT location_id, item_id, MIN(sales_date) AS first_date
  FROM base
  GROUP BY location_id, item_id
),
inv_cte (
    location_id, item_id, sales_date,
    receipts_qty, sales_qty,
    inventory_qty
) AS (
  -- anchor: start at each combo's first_date, opening inventory = 0 (change if you have opening stock)
  SELECT b.location_id,
         b.item_id,
         b.sales_date,
         b.receipts_qty,
         b.sales_qty,
         -- apply blank-day penalty when both receipts & sales are zero
         (0 + b.receipts_qty - b.sales_qty
           - CASE WHEN b.receipts_qty = 0 AND b.sales_qty = 0 THEN 10 ELSE 0 END
         ) AS inventory_qty
  FROM base b
  JOIN first_day f
    ON b.location_id = f.location_id
   AND b.item_id     = f.item_id
   AND b.sales_date  = f.first_date
  UNION ALL
  -- recursive: next calendar day for same combo
  SELECT b.location_id,
         b.item_id,
         b.sales_date,
         b.receipts_qty,
         b.sales_qty,
         (a.inventory_qty
           + b.receipts_qty
           - b.sales_qty
           - CASE WHEN b.receipts_qty = 0 AND b.sales_qty = 0 THEN 10 ELSE 0 END
         ) AS inventory_qty
  FROM inv_cte a
  JOIN base b
    ON b.location_id = a.location_id
   AND b.item_id     = a.item_id
   AND b.sales_date  = a.sales_date + 1
)
SELECT location_id,
       item_id,
       sales_date,
       receipts_qty,
       sales_qty,
       inventory_qty
FROM inv_cte
ORDER BY location_id, item_id, sales_date;






WITH combos AS (
  -- distinct combos and their date range (ignore NULL keys)
  SELECT location_id,
         item_id,
         MIN(sales_date) AS min_date,
         MAX(sales_date) AS max_date
  FROM inventory_txn
  WHERE location_id IS NOT NULL
    AND item_id     IS NOT NULL
  GROUP BY location_id, item_id
),
nums AS (
  -- number generator up to the largest span across combos
  SELECT LEVEL AS n
  FROM dual
  CONNECT BY LEVEL <= (
    SELECT NVL(MAX(max_date - min_date + 1), 0) FROM combos
  )
),
calendar AS (
  -- expand each combo into every date from min_date .. max_date
  SELECT c.location_id,
         c.item_id,
         c.min_date + (n.n - 1) AS sales_date
  FROM combos c
  JOIN nums n
    ON n.n <= (c.max_date - c.min_date + 1)
),
base AS (
  -- left-join actual transactions so missing days get zeros
  SELECT cal.location_id,
         cal.item_id,
         cal.sales_date,
         NVL(t.receipts_qty, 0) AS receipts_qty,
         NVL(t.sales_qty,   0) AS sales_qty,
         CASE WHEN t.location_id IS NULL THEN 1 ELSE 0 END AS is_blank
  FROM calendar cal
  LEFT JOIN inventory_txn t
    ON t.location_id = cal.location_id
   AND t.item_id     = cal.item_id
   AND t.sales_date  = cal.sales_date
),
first_day AS (
  -- first calendar date per combo (anchor for recursion)
  SELECT location_id, item_id, MIN(sales_date) AS first_date
  FROM base
  GROUP BY location_id, item_id
),
inv_cte (
    location_id, item_id, sales_date,
    receipts_qty, sales_qty,
    inventory_qty
) AS (
  -- anchor: start at each combo's first_date, opening inventory = 0 (change if you have opening stock)
  SELECT b.location_id,
         b.item_id,
         b.sales_date,
         b.receipts_qty,
         b.sales_qty,
         -- apply blank-day penalty when both receipts & sales are zero
         (0 + b.receipts_qty - b.sales_qty
--           - CASE WHEN b.receipts_qty = 0 AND b.sales_qty = 0 THEN 10 ELSE 0 END
           - CASE WHEN b.is_blank = 1 THEN 10 ELSE 0 END
         ) AS inventory_qty
  FROM base b
  JOIN first_day f
    ON b.location_id = f.location_id
   AND b.item_id     = f.item_id
   AND b.sales_date  = f.first_date
  UNION ALL
  -- recursive: next calendar day for same combo
  SELECT b.location_id,
         b.item_id,
         b.sales_date,
         b.receipts_qty,
         b.sales_qty,
         (a.inventory_qty
           + b.receipts_qty
           - b.sales_qty
--           - CASE WHEN b.receipts_qty = 0 AND b.sales_qty = 0 THEN 10 ELSE 0 END
           - CASE WHEN b.is_blank = 1 THEN 10 ELSE 0 END
         ) AS inventory_qty
  FROM inv_cte a
  JOIN base b
    ON b.location_id = a.location_id
   AND b.item_id     = a.item_id
   AND b.sales_date  = a.sales_date + 1
)
SELECT location_id,
       item_id,
       sales_date,
       receipts_qty,
       sales_qty,
       inventory_qty
FROM inv_cte
ORDER BY location_id, item_id, sales_date;



CREATE TABLE inventory_txn (
    location_id   VARCHAR2(20),
    item_id       VARCHAR2(20),
    sales_date    DATE,
    receipts_qty  NUMBER,
    sales_qty     NUMBER
);






WITH base AS (
    -- combine deliveries and sales per day per product
    SELECT d.location_id,
           d.item_id,
           d.shop_id,
           d.delivery_date AS tx_date,
           NVL(SUM(d.delivery_qty), 0) AS delivery_qty,
           0 AS sales_qty
    FROM delivery_table d
    WHERE d.delivery_date >= DATE '2025-09-01'
    GROUP BY d.location_id, d.item_id, d.shop_id, d.delivery_date
    UNION ALL
    SELECT s.location_id,
           s.item_id,
           s.shop_id,
           s.sales_date AS tx_date,
           0 AS delivery_qty,
           NVL(SUM(s.sales_qty), 0) AS sales_qty
    FROM sales_table s
    WHERE s.sales_date >= DATE '2025-09-01'
    GROUP BY s.location_id, s.item_id, s.shop_id, s.sales_date
),
calendar AS (
    -- list all distinct (loc,item,shop) that appear in September
    SELECT DISTINCT location_id, item_id, shop_id
    FROM base
),
anchors AS (
    -- get August 31 inventory
    SELECT i.location_id,
           i.item_id,
           i.shop_id,
           DATE '2025-08-31' AS tx_date,
           0 AS delivery_qty,
           0 AS sales_qty,
           i.inventory_qty AS inventory_qty
    FROM inventory_table i
    UNION ALL
    -- add missing items (new ones) with zero opening inventory
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           DATE '2025-08-31' AS tx_date,
           0, 0, 0
    FROM calendar c
    WHERE NOT EXISTS (
        SELECT 1
        FROM inventory_table i
        WHERE i.location_id = c.location_id
          AND i.item_id     = c.item_id
          AND i.shop_id     = c.shop_id
    )
),
merged AS (
    -- join deliveries and sales together
    SELECT b.location_id,
           b.item_id,
           b.shop_id,
           b.tx_date,
           SUM(b.delivery_qty) AS delivery_qty,
           SUM(b.sales_qty)    AS sales_qty,
           0                   AS inventory_qty
    FROM base b
    GROUP BY b.location_id, b.item_id, b.shop_id, b.tx_date
),
all_days AS (
    SELECT * FROM anchors
    UNION ALL
    SELECT * FROM merged
),
inv_cte (
    location_id,
    item_id,
    shop_id,
    tx_date,
    delivery_qty,
    sales_qty,
    inventory_qty
) AS (
    -- anchor: Aug 31
    SELECT a.location_id,
           a.item_id,
           a.shop_id,
           a.tx_date,
           a.delivery_qty,
           a.sales_qty,
           a.inventory_qty
    FROM anchors a
    UNION ALL
    -- recursive: next day inventory
    SELECT b.location_id,
           b.item_id,
           b.shop_id,
           b.tx_date,
           b.delivery_qty,
           b.sales_qty,
           (a.inventory_qty + b.delivery_qty - b.sales_qty) AS inventory_qty
    FROM inv_cte a
    JOIN all_days b
      ON b.location_id = a.location_id
     AND b.item_id     = a.item_id
     AND b.shop_id     = a.shop_id
     AND b.tx_date     = a.tx_date + 1
)
SELECT *
FROM inv_cte
WHERE location_id = 'loc01'
AND SHOP_ID = 'BestBuy'
AND TX_DATE < DATE '2025-09-02'
ORDER BY location_id, item_id, shop_id, tx_date;





SELECT
    COALESCE(a.id, b.id, c.id) AS common_id,
    a.col_a,
    b.col_b,
    c.col_c
FROM
    TableA a
FULL OUTER JOIN
    TableB b ON a.id = b.id
FULL OUTER JOIN
    TableC c ON COALESCE(a.id, b.id) = c.id;











WITH d AS (
  SELECT LOCATION_ID, ITEM_ID, SHOP_ID, QTY, STATUS, DATE_DELIVERED
  FROM DELIVERY_TABLE
)
SELECT
    a.LOCATION_ID,
    a.ITEM_ID,
    a.SHOP_ID,
    (SELECT QTY FROM d 
      WHERE d.LOCATION_ID = a.LOCATION_ID
        AND d.ITEM_ID = a.ITEM_ID
        AND d.SHOP_ID = a.SHOP_ID) AS QTY,
    (SELECT STATUS FROM d 
      WHERE d.LOCATION_ID = a.LOCATION_ID
        AND d.ITEM_ID = a.ITEM_ID
        AND d.SHOP_ID = a.SHOP_ID) AS STATUS,
    (SELECT DATE_DELIVERED FROM d 
      WHERE d.LOCATION_ID = a.LOCATION_ID
        AND d.ITEM_ID = a.ITEM_ID
        AND d.SHOP_ID = a.SHOP_ID) AS DATE_DELIVERED
FROM INVENTORY_TABLE a;


















WITH /*+ MATERIALIZE */ sales_agg AS (
    SELECT location_id, item_id, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id
),
/*+ MATERIALIZE */ delivery_agg AS (
    SELECT location_id, item_id, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id
),
/*+ MATERIALIZE */ inventory_agg AS (
    SELECT location_id, item_id, MAX(inventory_qty) AS inventory_qty
    FROM inventory_table
    GROUP BY location_id, item_id
)
SELECT /*+ LEADING(s d i) USE_HASH(d) USE_NL(i) */
       s.location_id,
       s.item_id,
       NVL(i.inventory_qty,0)
         + NVL(d.delivery_qty,0)
         - NVL(s.sales_qty,0) AS end_inventory
FROM sales_agg s
LEFT JOIN delivery_agg d ON s.location_id = d.location_id AND s.item_id = d.item_id
LEFT JOIN inventory_agg i ON s.location_id = i.location_id AND s.item_id = i.item_id;



SELECT /*+ LEADING(s d i) USE_HASH(d) USE_NL(i) */
       s.location_id, s.item_id, s.sales_qty, d.delivery_qty, i.inventory_qty
FROM sales_agg s
LEFT JOIN delivery_agg d ON ...
LEFT JOIN inventory_agg i ON ...;



| Hint                     | Behavior                               | Typical Use                 |
| ------------------------ | -------------------------------------- | --------------------------- |
| `/*+ MATERIALIZE */`     | Forces Oracle to compute and store CTE | Reused or large CTEs        |
| `/*+ INLINE */`          | Forces Oracle to inline the CTE        | Single-use small CTEs       |
| `/*+ USE_NL(alias) */`   | Nested Loop join                       | Small indexed tables        |
| `/*+ USE_HASH(alias) */` | Hash join                              | Large unindexed tables      |
| `/*+ LEADING(a b c) */`  | Fix join order                         | Prevents bad optimizer plan |


| Hint                     | Meaning            | Use when                                     |
| ------------------------ | ------------------ | -------------------------------------------- |
| `USE_NL(table_alias)`    | Nested Loop join   | Small dataset on right side, good indexes    |
| `USE_HASH(table_alias)`  | Hash Join          | Large datasets, memory is available          |
| `USE_MERGE(table_alias)` | Sort-Merge Join    | Both sides large, and join keys are sorted   |
| `LEADING(a b c)`         | Control join order | When Oracle picks a poor order automatically |





SELECT *
FROM customers
WHERE NVL(customer_name, 'NULL_FLAG') = 'NULL_FLAG';




| Situation                             | Example hint             | Why it helps                |
| ------------------------------------- | ------------------------ | --------------------------- |
| Oracle chooses wrong join order       | `LEADING(table1 table2)` | Force correct driving table |
| Oracle picks a slow join type         | `USE_HASH`, `USE_MERGE`  | Control join algorithm      |
| You need to avoid index for full scan | `FULL(table1)`           | Override bad index usage    |
| You want parallel execution           | `PARALLEL(table1, 4)`    | Speed up big queries        |
| You’re tuning a complex view or CTE   | `MATERIALIZE`, `INLINE`  | Control subquery evaluation |


SELECT /*+ USE_HASH(a b c d e f) PARALLEL(4) */
...

SELECT /*+ LEADING(a) USE_HASH(b c d e f) */

/*+ LEADING(a b c) */

/*+ LEADING(a) USE_NL(b c d e f) */



SELECT * FROM v$lock WHERE block > 0;
SELECT sid, event, p1text, p2text, p3text, wait_time, seconds_in_wait
FROM v$session
WHERE wait_class != 'Idle';

--enq: TX - row lock contention
--buffer busy waits
--log file sync



ALTER SESSION ENABLE PARALLEL DML;

INSERT /*+ APPEND PARALLEL(big_table 8) PARALLEL(target_table 8) */ INTO target_table
SELECT col1, col2, SUM(col3)
FROM big_table
GROUP BY col1, col2;
COMMIT;


INSERT INTO temp_stage
SELECT col1, col2, SUM(col3)
FROM big_table
GROUP BY col1, col2;

INSERT INTO target_table
SELECT * FROM temp_stage;


SELECT * FROM v$sql
WHERE sql_text LIKE '%/* test query */%'

SELECT * FROM v$sql_plan WHERE sql_id = '4a73s0scm16mr'

SELECT * FROM
table(dbms_xplan.display_cursor('4a73s0scm16mr'))


SELECT * FROM v$sqlarea;
SELECT * FROM v$sqlstats;
SELECT * FROM v$sql;
SELECT * FROM v$sql_plan;
SELECT * FROM v$sql_workarea;
SELECT * FROM v$sql_plan_statistics;
SELECT * FROM v$sql_plan_statistics_all;
 
 SELECT s.prod_id
  FROM sales s, customers c
  WHERE s.cust_id = c.cust_id;
 
select * from v$sql;
select * from v$sql where sql_text like '%SELECT s.prod_id 
                                           FROM sales s, customers c 
                                           WHERE s.cust_id = c.cust_id%';
select * from v$sql where sql_text like '%SELECT s.prod_id FROM sales s, customers c WHERE s.cust_id = c.cust_id%';
 
 SELECT /* my query */ s.prod_id
  FROM sales s, customers c
  WHERE s.cust_id = c.cust_id;
 
select * from v$sql where sql_text like '%my query%';
select * from v$sql_plan where sql_id = '';
select * from table(dbms_xplan.display_cursor(''));




DECLARE
  v_start NUMBER;
  v_end   NUMBER;
BEGIN
  v_start := DBMS_UTILITY.get_time;  -- time in 1/100ths of a second

  -- your query here
  FOR r IN (SELECT /*+ FULL(your_table) */ * FROM your_table WHERE your_condition) LOOP
    NULL;
  END LOOP;

  v_end := DBMS_UTILITY.get_time;
  DBMS_OUTPUT.put_line('Elapsed time: ' || TO_CHAR((v_end - v_start)/100) || ' seconds');
END;



SELECT index_name, status
FROM user_indexes
WHERE table_name = 'SALES';

INDEX_NAME           STATUS
-------------------- --------
SALES_IDX_CUSTOMER   UNUSABLE
SALES_IDX_DATE       UNUSABLE



-- Detect if a session is waiting
SELECT
    s.sid,
    s.serial#,
    s.username,
    s.status,
    s.event,
    s.wait_class,
    s.seconds_in_wait,
    s.state,
    s.sql_id,
    s.program
FROM v$session s
WHERE s.username IS NOT NULL
  AND s.status = 'ACTIVE'
ORDER BY s.seconds_in_wait DESC;


-- See what SQL is actually running
SELECT sql_text
FROM v$sql
WHERE sql_id = '&&sql_id';


-- Check if it’s waiting on locks (very common)
SELECT
    l1.sid AS waiting_session,
    s1.username AS waiting_user,
    l2.sid AS blocking_session,
    s2.username AS blocking_user,
    l1.id1, l1.id2, l1.lmode, l1.request
FROM v$lock l1
JOIN v$lock l2
  ON l1.id1 = l2.id1 AND l1.id2 = l2.id2
JOIN v$session s1 ON l1.sid = s1.sid
JOIN v$session s2 ON l2.sid = s2.sid
WHERE l1.block = 0 AND l2.block = 1;


-- Optional: see the overall wait breakdown
SELECT event, total_waits, time_waited, average_wait
FROM v$system_event
WHERE wait_class <> 'Idle'
ORDER BY time_waited DESC;


-- Check blocking objects (what table or row?)
SELECT
    s.sid,
    s.serial#,
    s.username,
    o.object_name,
    o.object_type
FROM v$session s
JOIN v$locked_object lo ON s.sid = lo.session_id
JOIN all_objects o ON lo.object_id = o.object_id;


-- (Optional) — Use V$ACTIVE_SESSION_HISTORY (if you have the Diagnostic Pack)
SELECT sample_time, session_id, session_state, event, wait_class, sql_id
FROM v$active_session_history
WHERE session_id = 288
ORDER BY sample_time DESC;


-- Tip: To find your current session
SELECT sid, serial#, username, program
FROM v$session
WHERE audsid = USERENV('SESSIONID');


Summary
Purpose	View / Query
Check current waits	v$session
Find blocking sessions	v$lock, v$session
See SQL causing delay	v$sql
Check which object is locked	v$locked_object, all_objects
Historical wait analysis	v$active_session_history (Diag. Pack)



/*+ star_transformation fact(s)*/

CALL DBMS_STATS.GATHER_TABLE_STATS('schema_name', 'table_name');



DECLARE
  v_rows NUMBER;
BEGIN
  LOOP
    DELETE FROM big_table
     WHERE condition
       AND ROWNUM <= 10000;  -- delete 10,000 rows per loop
    v_rows := SQL%ROWCOUNT;
    COMMIT;
    EXIT WHEN v_rows = 0;
  END LOOP;
END;



DECLARE
  v_rows NUMBER;
  v_start NUMBER;
  v_end   NUMBER;
BEGIN
  LOOP
    v_start := DBMS_UTILITY.get_time;

    DELETE FROM big_table
     WHERE condition
       AND ROWNUM <= 50000;  -- initial batch size
    v_rows := SQL%ROWCOUNT;
    COMMIT;

    v_end := DBMS_UTILITY.get_time;
    DBMS_OUTPUT.PUT_LINE('Deleted '||v_rows||' rows in '||(v_end-v_start)/100||' seconds.');

    EXIT WHEN v_rows = 0;
  END LOOP;
END;



DECLARE
  v_total NUMBER;
  v_deleted NUMBER := 0;
BEGIN
  SELECT COUNT(*) INTO v_total FROM big_table WHERE condition;

  WHILE v_deleted < v_total LOOP
    DELETE FROM big_table
     WHERE condition
       AND ROWNUM <= 50000;
    v_deleted := v_deleted + SQL%ROWCOUNT;
    COMMIT;
  END LOOP;
END;





SELECT 
    location_id,
    sales_date,
    SUM(quantity) AS total_qty,
    CASE 
        WHEN SUM(CASE WHEN item_name LIKE '%iPhone%' THEN 1 ELSE 0 END) > 0 
        THEN 'Y'
        ELSE 'N'
    END AS contains_iphone
FROM sales_table
GROUP BY location_id, sales_date;


SELECT 
    location_id,
    sales_date,
    SUM(quantity) AS total_qty,
    MAX(is_iphone) AS contains_iphone
FROM (
    SELECT 
        location_id,
        sales_date,
        item_name,
        quantity,
        CASE 
            WHEN item_name LIKE '%iPhone%' THEN 1
            ELSE 0
        END AS is_iphone
    FROM sales_table
)
GROUP BY location_id, sales_date;


SELECT
    location_id,
    sales_date,
    SUM(quantity) AS total_qty,
    CASE 
        WHEN EXISTS (
            SELECT 1 
            FROM sales_table s2
            WHERE s2.location_id = sales_table.location_id
              AND s2.sales_date = sales_table.sales_date
              AND s2.item_name LIKE '%iPhone%'
        ) THEN 'Y'
        ELSE 'N'
    END AS contains_iphone
FROM sales_table
GROUP BY location_id, sales_date;




WHERE ( rec.col1 IS NOT NULL AND salesid = rec.col1 )
   OR ( rec.col1 IS NULL AND salesid IS NULL )



CREATE TABLE high_volume_data (
    data_key     VARCHAR2(8) NOT NULL, -- e.g., '202510FR'
    ... -- other data columns
    record_date  DATE GENERATED ALWAYS AS (
        TO_DATE(SUBSTR(data_key, 1, 6) || SUBSTR(data_key, 7, 2), 'YYYYIWDD') 
        -- Note: Adjust date format model ('YYYYIWDD') based on your exact week/day calculation logic
    ) VIRTUAL
)
PARTITION BY RANGE (record_date)
INTERVAL (NUMTODSINTERVAL(1, 'DAY')) -- Automatically create 1-day interval partitions
(
    -- Initial range partition (transition point). 
    -- Data before this date goes here, new data after this date creates interval partitions.
    PARTITION p_initial VALUES LESS THAN (TO_DATE('2025-01-01', 'YYYY-MM-DD'))
);


CREATE TABLE sales (
    sale_id NUMBER,
    sale_date DATE,
    amount NUMBER
)
PARTITION BY RANGE (sale_date) (
    PARTITION p_sales_2023 VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD')), -- 2023년 데이터
    PARTITION p_sales_2024 VALUES LESS THAN (TO_DATE('2025-01-01', 'YYYY-MM-DD')), -- 2024년 데이터
    PARTITION p_sales_future VALUES LESS THAN (MAXVALUE) -- 2025년 이후 모든 데이터
);


CREATE TABLE sales_fact (
    sales_date DATE NOT NULL,
    location_id VARCHAR2(10),
    item_id VARCHAR2(20),
    sales_qty NUMBER
)
PARTITION BY RANGE (sales_date)
INTERVAL (NUMTOYMINTERVAL(1, 'YEAR'))
(
    PARTITION p_init VALUES LESS THAN (DATE '2025-01-01')
);



CREATE TABLE your_table (
    data_key        VARCHAR2(10) NOT NULL, -- e.g., '202510FR'
    ... -- other columns
    
    -- Virtual Column to extract a standard date for the key
    -- This assumes you have a way to translate '202510FR' into a valid DATE
    -- A simple approach might be to use a numeric value for partitioning
    -- (e.g., 202510) and manage the "day of week" within the partition.
    -- However, a date is best for rolling windows.
    partition_date AS (
        -- COMPLEX FUNCTION to convert 'YYYYWWDD' format to a DATE
        TO_DATE(SUBSTR(data_key, 1, 6) || '1', 'YYYYIWID') 
        + DECODE(SUBSTR(data_key, 7, 2), 
                 'SU', 0, 'MO', 1, 'TU', 2, 'WE', 3, 
                 'TH', 4, 'FR', 5, 'SA', 6)
        -- The above is a simplified example, your actual key-to-date logic 
        -- will depend on your specific week/day definition (ISO vs. Oracle default)
    ) VIRTUAL
)
PARTITION BY RANGE (partition_date)
...;


CREATE TABLE your_data_table (
    data_key        VARCHAR2(10) NOT NULL, -- e.g., '202510FR'
    ... -- other columns

    -- Virtual Column (the actual partition key, assuming you can derive a date)
    record_date AS (
        -- Replace this with your actual conversion logic for '202510FR' -> DATE
        -- For this example, we'll assume a virtual column named 'record_date' exists.
        TO_DATE('202510FR', 'YYYYIWID') -- Placeholder for real conversion
    ) VIRTUAL
)
PARTITION BY RANGE (record_date)
INTERVAL (NUMTODSINTERVAL(1, 'DAY')) -- Auto-create a new partition every day
(
    -- Initial required partition (a baseline or catch-all for old data)
    PARTITION p_initial VALUES LESS THAN (DATE '2025-01-01')
);


ALTER TABLE your_data_table DROP PARTITION FOR (DATE '2025-10-10')
-- Oracle automatically identifies and drops the partition corresponding to that date.
-- (Use a calculated date in your real-world automation, like SYSDATE - 15)

CREATE TABLE sales_fact (
    period_key  VARCHAR2(8) NOT NULL,  -- e.g. 202510FR

    sales_date  DATE
      GENERATED ALWAYS AS (
        TRUNC(
          TO_DATE(SUBSTR(period_key, 1, 4) || '0104', 'YYYYMMDD'),
          'IW'
        )
        + (TO_NUMBER(SUBSTR(period_key, 5, 2)) - 1) * 7
        + CASE SUBSTR(period_key, 7, 2)
            WHEN 'MO' THEN 0
            WHEN 'TU' THEN 1
            WHEN 'WE' THEN 2
            WHEN 'TH' THEN 3
            WHEN 'FR' THEN 4
            WHEN 'SA' THEN 5
            WHEN 'SU' THEN 6
          END
      ) VIRTUAL,

    location_id VARCHAR2(10),
    item_id     VARCHAR2(20),
    sales_qty   NUMBER
);


CREATE TABLE sales_fact (
    period_key  VARCHAR2(8) NOT NULL,  -- e.g. 202510FR

    sales_date  DATE
      GENERATED ALWAYS AS (
        TRUNC(
          TO_DATE(SUBSTR(period_key, 1, 4) || '0104', 'YYYYMMDD'),
          'IW'
        )
        + (TO_NUMBER(SUBSTR(period_key, 5, 2)) - 1) * 7
        + CASE SUBSTR(period_key, 7, 2)
            WHEN 'MO' THEN 0
            WHEN 'TU' THEN 1
            WHEN 'WE' THEN 2
            WHEN 'TH' THEN 3
            WHEN 'FR' THEN 4
            WHEN 'SA' THEN 5
            WHEN 'SU' THEN 6
          END
      ) VIRTUAL,

    location_id VARCHAR2(10),
    item_id     VARCHAR2(20),
    sales_qty   NUMBER
)
PARTITION BY RANGE (sales_date)
INTERVAL (NUMTODSINTERVAL(1, 'DAY'))
--INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
--INTERVAL (NUMTOYMINTERVAL(1, 'YEAR'))
(
    PARTITION p_init VALUES LESS THAN (DATE '2025-01-01')
);



ALTER TABLE sales_fact
DROP PARTITION FOR (TRUNC(SYSDATE) - 15);

How do I execute this command in an Oracle procedure?



CREATE OR REPLACE PROCEDURE drop_old_partition AS
    v_sql VARCHAR2(4000);
BEGIN
    v_sql :=
        'ALTER TABLE sales_fact DROP PARTITION FOR (DATE ''' ||
        TO_CHAR(TRUNC(SYSDATE) - 15, 'YYYY-MM-DD') ||
        ''')';

    EXECUTE IMMEDIATE v_sql;

EXCEPTION
    WHEN OTHERS THEN
        -- ORA-14010: partition does not exist
        IF SQLCODE = -14010 THEN
            NULL; -- ignore
        ELSE
            RAISE;
        END IF;
END;
/


CREATE OR REPLACE PROCEDURE drop_old_partition AS
    v_part_name user_tab_partitions.partition_name%TYPE;
BEGIN
    SELECT partition_name
    INTO   v_part_name
    FROM   user_tab_partitions
    WHERE  table_name = 'SALES_FACT'
    AND    high_value =
           'TO_DATE(''' ||
           TO_CHAR(TRUNC(SYSDATE) - 15, 'YYYY-MM-DD') ||
           ''',''YYYY-MM-DD'')';

    EXECUTE IMMEDIATE
        'ALTER TABLE sales_fact DROP PARTITION ' || v_part_name;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        NULL; -- partition not found, nothing to drop
END;
/


BEGIN
    DBMS_SCHEDULER.create_job (
        job_name        => 'DROP_OLD_SALES_PART',
        job_type        => 'STORED_PROCEDURE',
        job_action      => 'DROP_OLD_PARTITION',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=DAILY;BYHOUR=01',
        enabled         => TRUE
    );
END;
/

ALTER TABLE sales_fact
DROP PARTITION FOR (TRUNC(SYSDATE) - 15);







SELECT
    item,
    inventory_date,

    /* BEGINNING_INVENTORY */
    CASE
        WHEN rn = 1 THEN beginning_inventory
        ELSE
            first_begin_inv
            + running_delta
            - (receipts - shipments - expected_sales)
    END AS beginning_inventory,

    receipts,
    shipments,
    expected_sales,

    /* ENDING_INVENTORY */
    first_begin_inv
    + running_delta AS ending_inventory

FROM (
    SELECT
        item,
        inventory_date,
        beginning_inventory,
        receipts,
        shipments,
        expected_sales,

        /* Row number per ITEM (no hardcoded dates) */
        ROW_NUMBER() OVER (
            PARTITION BY item
            ORDER BY inventory_date
        ) AS rn,

        /* First beginning inventory per ITEM */
        FIRST_VALUE(beginning_inventory) OVER (
            PARTITION BY item
            ORDER BY inventory_date
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) AS first_begin_inv,

        /* Cumulative inventory change */
        SUM(receipts - shipments - expected_sales) OVER (
            PARTITION BY item
            ORDER BY inventory_date
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS running_delta

    FROM inventory_daily
    WHERE inventory_date BETWEEN DATE '2025-12-01' AND DATE '2025-12-31'
)
ORDER BY item, inventory_date;










SELECT
    item,
    start_date,
    end_date,
    inventory_qty
FROM (
    SELECT
        item,
        inventory_date AS start_date,

        /* End date = day before next snapshot */
        LEAST(
            NVL(
                LEAD(inventory_date) OVER (
                    PARTITION BY item
                    ORDER BY inventory_date
                ) - 1,
                DATE '2025-12-31'
            ),
            DATE '2025-12-31'
        ) AS end_date,

        inventory_qty
    FROM inventory_snapshot
)
WHERE inventory_qty > 0
ORDER BY item, start_date;




SELECT
    item,
    inventory_date,
    inventory_qty
FROM (
    SELECT
        item,
        inventory_qty,
        start_date + LEVEL - 1 AS inventory_date
    FROM (
        SELECT
            item,
            inventory_date AS start_date,
            inventory_qty,

            /* End date = day before next snapshot, capped at Dec 31 */
            LEAST(
                NVL(
                    LEAD(inventory_date) OVER (
                        PARTITION BY item
                        ORDER BY inventory_date
                    ) - 1,
                    DATE '2025-12-31'
                ),
                DATE '2025-12-31'
            ) AS end_date
        FROM inventory_snapshot
    )
    WHERE inventory_qty > 0
    CONNECT BY LEVEL <= (end_date - start_date + 1)
       AND PRIOR item = item
       AND PRIOR start_date = start_date
       AND PRIOR SYS_GUID() IS NOT NULL
)
ORDER BY item, inventory_date;





SELECT
    item,
    inventory_date,
    inventory_qty
FROM (
    SELECT
        item,
        inventory_qty,
        (start_date + LEVEL) AS inventory_date   -- start from NEXT day
    FROM (
        SELECT
            item,
            inventory_date AS start_date,
            inventory_qty,

            /* End date = day before next snapshot, capped at Dec 31 */
            LEAST(
                NVL(
                    LEAD(inventory_date) OVER (
                        PARTITION BY item
                        ORDER BY inventory_date
                    ) - 1,
                    DATE '2025-12-31'
                ),
                DATE '2025-12-31'
            ) AS end_date
        FROM inventory_snapshot
    )
    WHERE inventory_qty > 0
    CONNECT BY LEVEL <= (end_date - start_date)
       AND PRIOR item = item
       AND PRIOR start_date = start_date
       AND PRIOR SYS_GUID() IS NOT NULL
)
ORDER BY item, inventory_date;



SELECT
    d.cal_date AS inventory_date,
    s.item,
    s.inventory_qty
FROM calendar_dim d
JOIN inventory_snapshot s
  ON s.inventory_date = (
        SELECT MAX(s2.inventory_date)
        FROM inventory_snapshot s2
        WHERE s2.item = s.item
          AND s2.inventory_date < d.cal_date
     )
WHERE d.cal_date <= DATE '2025-12-31'
  AND s.inventory_qty > 0
ORDER BY s.item, d.cal_date;


SELECT sql_id, sql_text
FROM v$sql
WHERE sql_text LIKE '%MERGE INTO ITEM_DETAIL%';

SELECT *
FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(
    NULL,
    NULL,
    'ALL +PREDICATE +OUTLINE +NOTE'
  )
);

SELECT name, value, ismodified, description
FROM v$parameter
WHERE name = 'query_rewrite_enabled';

UPDATE INVENTORY_DAILY
SET ENDING_INVENTORY = BEGINNING_INVENTORY - RECEIPTS + SHIPMENTS
WHERE ENDING_INVENTORY <> BEGINNING_INVENTORY - RECEIPTS + SHIPMENTS

MERGE INTO config_table t
USING dual
ON (t.key = 'MAX_LIMIT')
WHEN MATCHED THEN
  UPDATE SET t.value = 100
WHEN NOT MATCHED THEN
  INSERT (key, value) VALUES ('MAX_LIMIT', 100);


MERGE INTO inventory_daily t
USING inventory_daily s
ON (t.item = s.item
AND  t.inventory_date = s.inventory_date)
WHEN MATCHED THEN
UPDATE SET
    t.ending_inventory =
        s.beginning_inventory - s.receipts + s.shipments
WHERE t.ending_inventory <>
      s.beginning_inventory - s.receipts + s.shipments;

MERGE INTO INVENTORY_DAILY t
USING (
    SELECT
        ITEM,
        INVENTORY_DATE,
        BEGINNING_INVENTORY,
        RECEIPTS,
        SHIPMENTS,
        BEGINNING_INVENTORY - RECEIPTS + SHIPMENTS AS CALC_ENDING
    FROM INVENTORY_DAILY
) s
ON (
       t.ITEM = s.ITEM
   AND t.INVENTORY_DATE = s.INVENTORY_DATE
)
WHEN MATCHED THEN
UPDATE SET
    t.ENDING_INVENTORY = s.CALC_ENDING
WHERE t.ENDING_INVENTORY <> s.CALC_ENDING;





DECLARE
    TYPE group_total_map  IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    TYPE region_group_map IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;

    v_group_totals   group_total_map;
    v_region_group   region_group_map;

    v_total_qty      NUMBER;
    v_avg_qty        NUMBER;

    v_best_group     PLS_INTEGER;
    v_min_total      NUMBER;

    v_groups CONSTANT PLS_INTEGER := 5;
BEGIN
    ----------------------------------------------------------------
    -- Initialize group totals (groups 1–5 → A–E)
    ----------------------------------------------------------------
    FOR i IN 1..v_groups LOOP
        v_group_totals(i) := 0;
    END LOOP;

    ----------------------------------------------------------------
    -- Compute total and average
    ----------------------------------------------------------------
    SELECT SUM(inventory_qty)
    INTO v_total_qty
    FROM region_inventory;

    v_avg_qty := v_total_qty / v_groups;

    DELETE FROM inventory_group_result;

    ----------------------------------------------------------------
    -- Process NON-ZERO inventory (largest first)
    ----------------------------------------------------------------
    FOR r IN (
        SELECT region_id, location_id, inventory_qty
        FROM region_inventory
        WHERE inventory_qty > 0
        ORDER BY inventory_qty DESC
    ) LOOP

        v_best_group := NULL;
        v_min_total  := 1e18;

        -- Try same-region group first (soft rule)
        IF v_region_group.EXISTS(TO_NUMBER(r.region_id)) THEN
            IF v_group_totals(v_region_group(TO_NUMBER(r.region_id)))
               + r.inventory_qty <= v_avg_qty * 1.15 THEN
                v_best_group := v_region_group(TO_NUMBER(r.region_id));
            END IF;
        END IF;

        -- Otherwise choose the lightest group
        IF v_best_group IS NULL THEN
            FOR i IN 1..v_groups LOOP
                IF v_group_totals(i) < v_min_total THEN
                    v_min_total  := v_group_totals(i);
                    v_best_group := i;
                END IF;
            END LOOP;
        END IF;

        -- Insert result
        INSERT INTO inventory_group_result
        VALUES (
            r.region_id,
            r.location_id,
            r.inventory_qty,
            CHR(64 + v_best_group)
        );

        -- Update totals
        v_group_totals(v_best_group) :=
            v_group_totals(v_best_group) + r.inventory_qty;

        -- Remember region assignment
        IF NOT v_region_group.EXISTS(TO_NUMBER(r.region_id)) THEN
            v_region_group(TO_NUMBER(r.region_id)) := v_best_group;
        END IF;

    END LOOP;

    ----------------------------------------------------------------
    -- Process ZERO inventory last
    ----------------------------------------------------------------
    FOR r IN (
        SELECT region_id, location_id, inventory_qty
        FROM region_inventory
        WHERE inventory_qty = 0
    ) LOOP
        v_min_total := 1e18;

        FOR i IN 1..v_groups LOOP
            IF v_group_totals(i) < v_min_total THEN
                v_min_total  := v_group_totals(i);
                v_best_group := i;
            END IF;
        END LOOP;

        INSERT INTO inventory_group_result
        VALUES (
            r.region_id,
            r.location_id,
            r.inventory_qty,
            CHR(64 + v_best_group)
        );
    END LOOP;

    COMMIT;
END;



SELECT *
FROM inventory_group_result
ORDER BY inventory_group, inventory_qty DESC;


SELECT region_id,
       COUNT(DISTINCT inventory_group) AS group_count
FROM inventory_group_result
GROUP BY region_id
HAVING COUNT(DISTINCT inventory_group) > 1;








DECLARE
    TYPE num_map    IS TABLE OF NUMBER  INDEX BY PLS_INTEGER;
    TYPE int_map    IS TABLE OF INTEGER INDEX BY PLS_INTEGER;
    TYPE bool_map   IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;

    v_group_totals   num_map;
    v_region_group   int_map;
    v_region_split   bool_map;

    v_total_qty      NUMBER;
    v_avg_qty        NUMBER;

    v_best_group     PLS_INTEGER;
    v_min_total      NUMBER;

    v_groups CONSTANT PLS_INTEGER := 5;
BEGIN
    ------------------------------------------------------------
    -- Init
    ------------------------------------------------------------
    FOR i IN 1..v_groups LOOP
        v_group_totals(i) := 0;
    END LOOP;

    SELECT SUM(inventory_qty)
    INTO v_total_qty
    FROM region_inventory;

    v_avg_qty := v_total_qty / v_groups;

    DELETE FROM inventory_group_result;

    ------------------------------------------------------------
    -- NON-ZERO inventory (largest first)
    ------------------------------------------------------------
    FOR r IN (
        SELECT region_id, location_id, inventory_qty
        FROM region_inventory
        WHERE inventory_qty > 0
        ORDER BY inventory_qty DESC
    ) LOOP

        v_best_group := NULL;

        --------------------------------------------------------
        -- Rule 1: Region cohesion ONLY if region not split
        --------------------------------------------------------
        IF v_region_group.EXISTS(r.region_id)
           AND NOT v_region_split.EXISTS(r.region_id)
        THEN
            -- Allow cohesion only if it does not worsen imbalance
            IF v_group_totals(v_region_group(r.region_id))
               + r.inventory_qty
               <= v_avg_qty * 1.05
            THEN
                v_best_group := v_region_group(r.region_id);
            END IF;
        END IF;

        --------------------------------------------------------
        -- Rule 2: Balance-first fallback
        --------------------------------------------------------
        IF v_best_group IS NULL THEN
            v_min_total := 1e18;
            FOR i IN 1..v_groups LOOP
                IF v_group_totals(i) < v_min_total THEN
                    v_min_total  := v_group_totals(i);
                    v_best_group := i;
                END IF;
            END LOOP;
        END IF;

        --------------------------------------------------------
        -- Detect region split
        --------------------------------------------------------
        IF v_region_group.EXISTS(r.region_id)
           AND v_region_group(r.region_id) <> v_best_group
        THEN
            v_region_split(r.region_id) := TRUE;
        END IF;

        --------------------------------------------------------
        -- Save
        --------------------------------------------------------
        INSERT INTO inventory_group_result
        VALUES (
            r.region_id,
            r.location_id,
            r.inventory_qty,
            CHR(64 + v_best_group)
        );

        v_group_totals(v_best_group) :=
            v_group_totals(v_best_group) + r.inventory_qty;

        IF NOT v_region_group.EXISTS(r.region_id) THEN
            v_region_group(r.region_id) := v_best_group;
        END IF;

    END LOOP;

    ------------------------------------------------------------
    -- ZERO inventory
    ------------------------------------------------------------
    FOR r IN (
        SELECT region_id, location_id, inventory_qty
        FROM region_inventory
        WHERE inventory_qty = 0
    ) LOOP

        IF v_region_group.EXISTS(r.region_id)
           AND NOT v_region_split.EXISTS(r.region_id)
        THEN
            v_best_group := v_region_group(r.region_id);
        ELSE
            v_min_total := 1e18;
            FOR i IN 1..v_groups LOOP
                IF v_group_totals(i) < v_min_total THEN
                    v_min_total  := v_group_totals(i);
                    v_best_group := i;
                END IF;
            END LOOP;
        END IF;

        INSERT INTO inventory_group_result
        VALUES (
            r.region_id,
            r.location_id,
            r.inventory_qty,
            CHR(64 + v_best_group)
        );

    END LOOP;

    COMMIT;
END;






DECLARE
  -- 1. NUMBER 형식의 테이블 타입 정의
  TYPE t_num_tab IS TABLE OF NUMBER;
  
  -- 2. 변수 선언 및 초기화
  v_numbers t_num_tab := t_num_tab(10, 20, 30); -- 1, 2, 3 인덱스에 데이터 존재
BEGIN
    -- 3. 루프를 돌며 DBMS_OUTPUT으로 내용 확인
    IF v_numbers.COUNT > 0 THEN
        FOR i IN v_numbers.FIRST .. v_numbers.LAST LOOP
            DBMS_OUTPUT.PUT_LINE('Index ' || i || ': ' || v_numbers(i));
        END LOOP;
    ELSE
        DBMS_OUTPUT.PUT_LINE('컬렉션이 비어 있습니다.');
    END IF;
  -- 3. EXISTS를 사용하여 특정 인덱스 확인
  IF v_numbers.EXISTS(2) THEN
    DBMS_OUTPUT.PUT_LINE('인덱스 2가 존재합니다. 값: ' || v_numbers(2));
  ELSE
    DBMS_OUTPUT.PUT_LINE('인덱스 2가 없습니다.');
  END IF;

  -- 4. 존재하지 않는 인덱스 확인 (인덱스 5는 없음)
  IF v_numbers.EXISTS(5) THEN
    DBMS_OUTPUT.PUT_LINE('인덱스 5가 존재합니다.');
  ELSE
    DBMS_OUTPUT.PUT_LINE('인덱스 5가 존재하지 않습니다.');
  END IF;
  
  -- 5. 삭제된 인덱스 확인
  v_numbers.DELETE(3);
  IF NOT v_numbers.EXISTS(3) THEN
    DBMS_OUTPUT.PUT_LINE('인덱스 3이 삭제되어 존재하지 않습니다.');
  END IF;
END;




DECLARE
    TYPE bool_map IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;
    v_region_split bool_map;
BEGIN
    -- example data
    v_region_split(3) := TRUE;
    v_region_split(7) := FALSE;

    IF v_region_split.COUNT > 0 THEN
        FOR i IN v_region_split.FIRST .. v_region_split.LAST LOOP
            IF v_region_split.EXISTS(i) THEN
                DBMS_OUTPUT.PUT_LINE(
                    'Index ' || i || ': ' ||
                    CASE
                        WHEN v_region_split(i) THEN 'TRUE'
                        ELSE 'FALSE'
                    END
                );
            END IF;
        END LOOP;
    ELSE
        DBMS_OUTPUT.PUT_LINE('v_region_split empty');
    END IF;
END;







DECLARE
    TYPE num_map    IS TABLE OF NUMBER  INDEX BY PLS_INTEGER;
    TYPE int_map    IS TABLE OF INTEGER INDEX BY PLS_INTEGER;
    TYPE bool_map   IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;

    v_group_totals   num_map;
    v_region_group   int_map;
    v_region_split   bool_map;

    v_total_qty      NUMBER;
    v_avg_qty        NUMBER;

    v_best_group     PLS_INTEGER;
    v_min_total      NUMBER;

    v_groups CONSTANT PLS_INTEGER := 5;
BEGIN
    ------------------------------------------------------------
    -- Init
    ------------------------------------------------------------
    FOR i IN 1..v_groups LOOP
        v_group_totals(i) := 0;
    END LOOP;

    SELECT SUM(inventory_qty)
    INTO v_total_qty
    FROM region_inventory;

    v_avg_qty := v_total_qty / v_groups;

    DELETE FROM inventory_group_result;

    ------------------------------------------------------------
    -- NON-ZERO inventory (largest first)
    ------------------------------------------------------------
    FOR r IN (
        SELECT region_id, location_id, inventory_qty
        FROM region_inventory
        WHERE inventory_qty > 0
        ORDER BY inventory_qty DESC
    ) LOOP

        v_best_group := NULL;

        --------------------------------------------------------
        -- Rule 1: Region cohesion ONLY if region not split
        --------------------------------------------------------
        IF v_region_group.EXISTS(r.region_id)
           AND NOT v_region_split.EXISTS(r.region_id)
        THEN
            -- Allow cohesion only if it does not worsen imbalance
            IF v_group_totals(v_region_group(r.region_id))
               + r.inventory_qty
               <= v_avg_qty * 1.05
            THEN
                v_best_group := v_region_group(r.region_id);
            END IF;
        END IF;

        --------------------------------------------------------
        -- Rule 2: Balance-first fallback
        --------------------------------------------------------
        IF v_best_group IS NULL THEN
            v_min_total := 1e18;
            FOR i IN 1..v_groups LOOP
                IF v_group_totals(i) < v_min_total THEN
                    v_min_total  := v_group_totals(i);
                    v_best_group := i;
                END IF;
            END LOOP;
        END IF;

        --------------------------------------------------------
        -- Detect region split
        --------------------------------------------------------
        IF v_region_group.EXISTS(r.region_id)
           AND v_region_group(r.region_id) <> v_best_group
        THEN
            v_region_split(r.region_id) := TRUE;
        END IF;

        --------------------------------------------------------
        -- Save
        --------------------------------------------------------
        INSERT INTO inventory_group_result
        VALUES (
            r.region_id,
            r.location_id,
            r.inventory_qty,
            CHR(64 + v_best_group)
        );

        v_group_totals(v_best_group) :=
            v_group_totals(v_best_group) + r.inventory_qty;

        IF NOT v_region_group.EXISTS(r.region_id) THEN
            v_region_group(r.region_id) := v_best_group;
        END IF;

    END LOOP;

    ------------------------------------------------------------
    -- ZERO inventory
    ------------------------------------------------------------
    FOR r IN (
        SELECT region_id, location_id, inventory_qty
        FROM region_inventory
        WHERE inventory_qty = 0
    ) LOOP

        IF v_region_group.EXISTS(r.region_id)
           AND NOT v_region_split.EXISTS(r.region_id)
        THEN
            v_best_group := v_region_group(r.region_id);
        ELSE
            v_min_total := 1e18;
            FOR i IN 1..v_groups LOOP
                IF v_group_totals(i) < v_min_total THEN
                    v_min_total  := v_group_totals(i);
                    v_best_group := i;
                END IF;
            END LOOP;
        END IF;

        INSERT INTO inventory_group_result
        VALUES (
            r.region_id,
            r.location_id,
            r.inventory_qty,
            CHR(64 + v_best_group)
        );

    END LOOP;

    COMMIT;
END;


SELECT *
FROM inventory_group_result
ORDER BY inventory_group, inventory_qty DESC;



SELECT region_id,
       COUNT(DISTINCT inventory_group) AS group_count
FROM inventory_group_result
GROUP BY region_id
HAVING COUNT(DISTINCT inventory_group) > 1;




SELECT INVENTORY_GROUP, SUM(INVENTORY_QTY)
FROM REGION_INVENTORY_GROUPED
GROUP BY INVENTORY_GROUP 





DECLARE
    ------------------------------------------------------------------
    -- Configuration
    ------------------------------------------------------------------
    v_groups CONSTANT PLS_INTEGER := 5; -- A..E

    ------------------------------------------------------------------
    -- Totals & averages
    ------------------------------------------------------------------
    v_total_qty   NUMBER := 0;
    v_avg_qty     NUMBER := 0;

    ------------------------------------------------------------------
    -- Group totals
    ------------------------------------------------------------------
    TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    v_group_totals num_tab;

    ------------------------------------------------------------------
    -- Region → primary group
    ------------------------------------------------------------------
    TYPE region_group_tab IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;
    v_region_group region_group_tab;

    ------------------------------------------------------------------
    -- Region split flag
    ------------------------------------------------------------------
    TYPE region_split_tab IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;
    v_region_split region_split_tab;

    ------------------------------------------------------------------
    -- Region → secondary group (for small/zero rows after split)
    ------------------------------------------------------------------
    TYPE region_secondary_group_tab IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;
    v_region_secondary_group region_secondary_group_tab;

    ------------------------------------------------------------------
    -- Working variables
    ------------------------------------------------------------------
    v_best_group PLS_INTEGER;
    v_min_total  NUMBER;
BEGIN
    ------------------------------------------------------------------
    -- Initialize group totals
    ------------------------------------------------------------------
    FOR i IN 1..v_groups LOOP
        v_group_totals(i) := 0;
    END LOOP;

    ------------------------------------------------------------------
    -- Compute total inventory and average per group
    ------------------------------------------------------------------
    SELECT SUM(inventory_qty)
    INTO v_total_qty
    FROM region_inventory;

    v_avg_qty := v_total_qty / v_groups;

    ------------------------------------------------------------------
    -- Clear output table
    ------------------------------------------------------------------
    DELETE FROM region_inventory_grouped;

    ------------------------------------------------------------------
    -- 1️⃣ Process NON-ZERO inventory (largest first)
    ------------------------------------------------------------------
    FOR r IN (
        SELECT region_id, location_id, inventory_qty
        FROM region_inventory
        WHERE inventory_qty > 0
        ORDER BY inventory_qty DESC
    ) LOOP

        v_best_group := NULL;

        ------------------------------------------------------------------
        -- Case 1: Region not seen yet → assign to smallest group
        ------------------------------------------------------------------
        IF NOT v_region_group.EXISTS(r.region_id) THEN
            v_min_total := 1e18;
            FOR i IN 1..v_groups LOOP
                IF v_group_totals(i) < v_min_total THEN
                    v_min_total := v_group_totals(i);
                    v_best_group := i;
                END IF;
            END LOOP;

            v_region_group(r.region_id) := v_best_group;

        ELSE
            ------------------------------------------------------------------
            -- Region already seen
            ------------------------------------------------------------------
            IF r.inventory_qty >= v_avg_qty THEN
                -- Large row → allow split
                v_region_split(r.region_id) := TRUE;
                v_min_total := 1e18;
                FOR i IN 1..v_groups LOOP
                    IF v_group_totals(i) < v_min_total THEN
                        v_min_total := v_group_totals(i);
                        v_best_group := i;
                    END IF;
                END LOOP;
            ELSE
                -- Small row
                IF v_region_secondary_group.EXISTS(r.region_id) THEN
                    v_best_group := v_region_secondary_group(r.region_id);
                ELSIF v_region_split.EXISTS(r.region_id) THEN
                    -- First small row after split chooses secondary group
                    v_min_total := 1e18;
                    FOR i IN 1..v_groups LOOP
                        IF v_group_totals(i) < v_min_total THEN
                            v_min_total := v_group_totals(i);
                            v_best_group := i;
                        END IF;
                    END LOOP;
                    v_region_secondary_group(r.region_id) := v_best_group;
                ELSE
                    -- Region not split → follow primary group
                    v_best_group := v_region_group(r.region_id);
                END IF;
            END IF;
        END IF;

        ------------------------------------------------------------------
        -- Apply assignment
        ------------------------------------------------------------------
        v_group_totals(v_best_group) :=
            v_group_totals(v_best_group) + r.inventory_qty;

        INSERT INTO region_inventory_grouped
        VALUES (
            r.region_id,
            r.location_id,
            r.inventory_qty,
            CHR(64 + v_best_group) -- 1=A, 2=B...
        );
    END LOOP;

    ------------------------------------------------------------------
    -- 2️⃣ Process ZERO inventory
    ------------------------------------------------------------------
    FOR r IN (
        SELECT region_id, location_id, inventory_qty
        FROM region_inventory
        WHERE inventory_qty = 0
    ) LOOP

        IF v_region_secondary_group.EXISTS(r.region_id) THEN
            v_best_group := v_region_secondary_group(r.region_id);
        ELSIF v_region_group.EXISTS(r.region_id)
              AND NOT v_region_split.EXISTS(r.region_id)
        THEN
            v_best_group := v_region_group(r.region_id);
        ELSE
            v_min_total := 1e18;
            FOR i IN 1..v_groups LOOP
                IF v_group_totals(i) < v_min_total THEN
                    v_min_total := v_group_totals(i);
                    v_best_group := i;
                END IF;
            END LOOP;
        END IF;

        INSERT INTO region_inventory_grouped
        VALUES (
            r.region_id,
            r.location_id,
            r.inventory_qty,
            CHR(64 + v_best_group)
        );
    END LOOP;

    COMMIT;
END;


MERGE INTO inventory_group_result tgt
USING (
    SELECT
        region_id,
        DENSE_RANK() OVER (
            ORDER BY SUM(inventory_qty) DESC
        ) AS region_rank
    FROM inventory_group_result
    GROUP BY region_id
) src
ON (tgt.region_id = src.region_id)
WHEN MATCHED THEN
    UPDATE SET tgt.region_rank = src.region_rank;










