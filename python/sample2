

CREATE OR REPLACE PROCEDURE load_performance IS
    -- Cursor for departments
    CURSOR dept_cur IS
        SELECT deptno
        FROM dept;

    -- Cursor for employees in a department
    CURSOR emp_cur(p_deptno dept.deptno%TYPE) IS
        SELECT empno
        FROM emp
        WHERE deptno = p_deptno;

    -- Cursor for sales by employee, grouped by date
    CURSOR sales_cur(p_empno emp.empno%TYPE) IS
        SELECT sale_date,
               SUM(sales_amount) AS total_sales
        FROM sales
        WHERE empno = p_empno
        GROUP BY sale_date;
BEGIN
    -- Loop through departments
    FOR d IN dept_cur LOOP
        -- Loop through employees in each department
        FOR e IN emp_cur(d.deptno) LOOP
            -- Loop through sales totals for each employee
            FOR s IN sales_cur(e.empno) LOOP
                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (d.deptno, e.empno, s.sale_date, s.total_sales);
            END LOOP;
        END LOOP;
    END LOOP;

    COMMIT;
END load_performance;




CREATE OR REPLACE PROCEDURE update_emp_performance_bulk IS
    -- Record type for employee updates
    TYPE emp_perf_rec IS RECORD (
        empno      emp.empno%TYPE,
        total_perf NUMBER
    );

    -- Table type for bulk processing
    TYPE emp_perf_tab IS TABLE OF emp_perf_rec;
    l_emp_perf emp_perf_tab;

    -- Cursor for batching
    CURSOR c_perf IS
        SELECT empno, SUM(total_sales) AS total_perf
        FROM performance
        GROUP BY empno;

    l_limit CONSTANT PLS_INTEGER := 10000;  -- chunk size
    l_count PLS_INTEGER := 0;
BEGIN
    OPEN c_perf;
    LOOP
        FETCH c_perf BULK COLLECT INTO l_emp_perf LIMIT l_limit;
        EXIT WHEN l_emp_perf.COUNT = 0;

        -- Bulk update EMP using FORALL
        FORALL i IN 1 .. l_emp_perf.COUNT
            UPDATE emp
            SET performance = l_emp_perf(i).total_perf
            WHERE empno = l_emp_perf(i).empno;

        COMMIT;  -- commit after each chunk
        l_count := l_count + l_emp_perf.COUNT;
        DBMS_OUTPUT.PUT_LINE('Updated ' || l_count || ' rows so far...');
    END LOOP;

    CLOSE c_perf;
    DBMS_OUTPUT.PUT_LINE('All EMP rows updated successfully.');
END update_emp_performance_bulk;
/


CREATE OR REPLACE PROCEDURE load_performance IS
BEGIN
    -- Loop over departments
    FOR d IN (SELECT deptno FROM dept) LOOP
        -- Loop over employees in each department
        FOR e IN (SELECT empno FROM emp WHERE deptno = d.deptno) LOOP
            -- Loop over sales totals by date for each employee
            FOR s IN (SELECT sale_date,
                             SUM(sales_amount) AS total_sales
                      FROM sales
                      WHERE empno = e.empno
                      GROUP BY sale_date) LOOP

                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (d.deptno, e.empno, s.sale_date, s.total_sales);

            END LOOP;
        END LOOP;
    END LOOP;

    COMMIT;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    c_dept   SYS_REFCURSOR;
    c_emp    SYS_REFCURSOR;
    c_sales  SYS_REFCURSOR;

    v_deptno dept.deptno%TYPE;
    v_empno  emp.empno%TYPE;
    v_date   sales.sale_date%TYPE;
    v_total  NUMBER;
BEGIN
    OPEN c_dept FOR SELECT deptno FROM dept;
    LOOP
        FETCH c_dept INTO v_deptno; EXIT WHEN c_dept%NOTFOUND;

        OPEN c_emp FOR SELECT empno FROM emp WHERE deptno = v_deptno;
        LOOP
            FETCH c_emp INTO v_empno; EXIT WHEN c_emp%NOTFOUND;

            OPEN c_sales FOR
                SELECT sale_date, SUM(sales_amount)
                FROM sales
                WHERE empno = v_empno
                GROUP BY sale_date;

            LOOP
                FETCH c_sales INTO v_date, v_total; EXIT WHEN c_sales%NOTFOUND;

                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (v_deptno, v_empno, v_date, v_total);

            END LOOP;
            CLOSE c_sales;
        END LOOP;
        CLOSE c_emp;
    END LOOP;
    CLOSE c_dept;

    COMMIT;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    v_count PLS_INTEGER := 0;
BEGIN
    -- Loop over departments
    FOR d IN (SELECT deptno FROM dept) LOOP
        -- Loop over employees in each department
        FOR e IN (SELECT empno FROM emp WHERE deptno = d.deptno) LOOP
            -- Loop over sales totals by date for each employee
            FOR s IN (SELECT sale_date,
                             SUM(sales_amount) AS total_sales
                      FROM sales
                      WHERE empno = e.empno
                      GROUP BY sale_date) LOOP

                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (d.deptno, e.empno, s.sale_date, s.total_sales);

                v_count := v_count + 1;

                -- Commit every 10,000 rows
                IF MOD(v_count, 10000) = 0 THEN
                    COMMIT;
                END IF;

            END LOOP;
        END LOOP;
    END LOOP;

    -- Final commit for leftovers
    COMMIT;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    TYPE perf_tab IS TABLE OF performance%ROWTYPE;
    l_data perf_tab;
BEGIN
    -- Fetch everything in one SELECT
    SELECT e.deptno, s.empno, s.sale_date, SUM(s.sales_amount)
    BULK COLLECT INTO l_data
    FROM emp e
         JOIN sales s ON e.empno = s.empno
         JOIN dept d  ON e.deptno = d.deptno
    GROUP BY e.deptno, s.empno, s.sale_date;

    -- Insert in chunks of 10,000
    FOR i IN 1 .. CEIL(l_data.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_data.COUNT)
            INSERT INTO performance VALUES l_data(j);
        COMMIT;
    END LOOP;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    TYPE perf_tab IS TABLE OF performance%ROWTYPE;
    l_data perf_tab;
BEGIN
    -- Collect everything with one query
    SELECT e.deptno, s.empno, s.sale_date, SUM(s.sales_amount)
    BULK COLLECT INTO l_data
    FROM   emp e
           JOIN sales s ON e.empno = s.empno
           JOIN dept d  ON e.deptno = d.deptno
    GROUP  BY e.deptno, s.empno, s.sale_date;

    -- Insert in chunks of 10,000
    FOR i IN 1 .. CEIL(l_data.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_data.COUNT)
            INSERT INTO performance VALUES l_data(j);
        COMMIT;
    END LOOP;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    -- Custom record type matching the 4 columns we insert
    TYPE perf_rec IS RECORD (
        deptno      performance.deptno%TYPE,
        empno       performance.empno%TYPE,
        sale_date   performance.sale_date%TYPE,
        total_sales performance.total_sales%TYPE
    );

    -- Table type for bulk processing
    TYPE perf_tab IS TABLE OF perf_rec;
    l_data perf_tab;
BEGIN
    -- Bulk collect from sales aggregation
    SELECT e.deptno,
           s.empno,
           s.sale_date,
           SUM(s.sales_amount)
    BULK COLLECT INTO l_data
    FROM   emp e
           JOIN sales s ON e.empno = s.empno
           JOIN dept d  ON e.deptno = d.deptno
    GROUP  BY e.deptno, s.empno, s.sale_date;

    -- Insert in chunks of 10,000 rows
    FOR i IN 1 .. CEIL(l_data.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_data.COUNT)
            INSERT INTO performance (deptno, empno, sale_date, total_sales)
            VALUES (l_data(j).deptno,
                    l_data(j).empno,
                    l_data(j).sale_date,
                    l_data(j).total_sales);

        COMMIT;
    END LOOP;
END load_performance;




CREATE OR REPLACE PROCEDURE load_and_update_performance IS
    -- Type for bulk collecting performance inserts
    TYPE perf_rec IS RECORD (
        deptno      performance.deptno%TYPE,
        empno       performance.empno%TYPE,
        sale_date   performance.sale_date%TYPE,
        total_sales performance.total_sales%TYPE
    );

    TYPE perf_tab IS TABLE OF perf_rec;
    l_perf perf_tab;

    -- Type for updating EMP.performance
    TYPE emp_perf_rec IS RECORD (
        empno       emp.empno%TYPE,
        total_perf  NUMBER
    );

    TYPE emp_perf_tab IS TABLE OF emp_perf_rec;
    l_emp_perf emp_perf_tab;
BEGIN
    -- 1️⃣ Bulk collect aggregated sales into collection
    SELECT e.deptno,
           s.empno,
           s.sale_date,
           SUM(s.sales_amount) AS total_sales
    BULK COLLECT INTO l_perf
    FROM   emp e
           JOIN sales s ON e.empno = s.empno
           JOIN dept d  ON e.deptno = d.deptno
    GROUP  BY e.deptno, s.empno, s.sale_date;

    -- 2️⃣ Insert into PERFORMANCE in chunks of 10,000 rows
    FOR i IN 1 .. CEIL(l_perf.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_perf.COUNT)
            INSERT INTO performance (deptno, empno, sale_date, total_sales)
            VALUES (l_perf(j).deptno,
                    l_perf(j).empno,
                    l_perf(j).sale_date,
                    l_perf(j).total_sales);

        COMMIT; -- commit after each chunk
    END LOOP;

    -- 3️⃣ Collect total performance per employee for EMP update
    SELECT empno, SUM(total_sales) AS total_perf
    BULK COLLECT INTO l_emp_perf
    FROM performance
    GROUP BY empno;

    -- 4️⃣ Bulk update EMP.performance
    FORALL i IN 1 .. l_emp_perf.COUNT
        UPDATE emp
        SET performance = l_emp_perf(i).total_perf
        WHERE empno = l_emp_perf(i).empno;

    COMMIT; -- final commit after updating EMP
END load_and_update_performance;



INSERT /*+ APPEND */ INTO performance (deptno, empno, sale_date, total_sales)
SELECT e.deptno,
       s.empno,
       s.sale_date,
       SUM(s.sales_amount)
FROM   emp e
       JOIN sales s ON e.empno = s.empno
GROUP  BY e.deptno, s.empno, s.sale_date;




DECLARE
    CURSOR c_data IS
        SELECT e.deptno, s.empno, s.sale_date, SUM(s.sales_amount) AS total_sales
        FROM emp e
             JOIN sales s ON e.empno = s.empno
        GROUP BY e.deptno, s.empno, s.sale_date;
    TYPE perf_tab IS TABLE OF performance%ROWTYPE;
    l_data perf_tab;
BEGIN
    OPEN c_data;
    LOOP
        FETCH c_data BULK COLLECT INTO l_data LIMIT 10000;  -- fetch 10k at a time
        EXIT WHEN l_data.COUNT = 0;

        FORALL i IN 1 .. l_data.COUNT
            INSERT INTO performance (deptno, empno, sale_date, total_sales)
            VALUES (l_data(i).deptno, l_data(i).empno, l_data(i).sale_date, l_data(i).total_sales);

        COMMIT;  -- commit after each chunk
    END LOOP;
    CLOSE c_data;
END;


UPDATE (
    SELECT t1.column1, t1.column2, t2.new_column1, t2.new_column2
    FROM your_table t1
    JOIN another_table t2
      ON t1.id = t2.id
     AND t2.some_condition
) v
SET v.column1 = v.new_column1,
    v.column2 = v.new_column2;




























WITH
-- 1) combos
combos AS (
    SELECT DISTINCT location_id, item_id, shop_id
    FROM (
        SELECT location_id, item_id, shop_id FROM inventory_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM delivery_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM sales_table
    )
),
-- 2) calendar dates
dates AS (
    SELECT date_seq, date_key, day_of_week, date_week, year_of_day
    FROM date_table
    WHERE date_seq BETWEEN DATE '2025-07-31' AND DATE '2025-10-31'
),
-- 3) full calendar per combo
calendar AS (
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           d.date_seq,
           d.date_key,
           d.day_of_week,
           TRUNC(d.date_seq, 'IW') AS week_monday
    FROM combos c
    CROSS JOIN dates d
),
-- 4) aggregates on source tables
inv_agg AS (
    SELECT location_id, item_id, shop_id, inventory_date, SUM(inventory_qty) AS inventory_qty
    FROM inventory_table
    GROUP BY location_id, item_id, shop_id, inventory_date
),
del_agg AS (
    SELECT location_id, item_id, shop_id, delivery_date, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id, shop_id, delivery_date
),
sal_agg AS (
    SELECT location_id, item_id, shop_id, sales_date, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id, shop_id, sales_date
),
-- 5) daily rows w/ running inventory (inventory = running sum of inv + del - sales)
daily_data AS (
    SELECT
        cal.location_id,
        cal.item_id,
        cal.shop_id,
        cal.date_seq,
        cal.date_key,
        cal.day_of_week,
        -- running balance (end-of-day inventory)
        SUM(NVL(inv.inventory_qty,0) + NVL(del.delivery_qty,0) - NVL(sal.sales_qty,0))
          OVER (PARTITION BY cal.location_id, cal.item_id, cal.shop_id
                ORDER BY cal.date_seq
                ROWS UNBOUNDED PRECEDING) AS inventory_qty,
        NVL(del.delivery_qty,0) AS delivery_qty,
        NVL(sal.sales_qty,0)    AS sales_qty,
        (NVL(del.delivery_qty,0) - NVL(sal.sales_qty,0)) AS day_result,
        cal.week_monday
    FROM calendar cal
    LEFT JOIN inv_agg inv
      ON cal.location_id = inv.location_id
     AND cal.item_id     = inv.item_id
     AND cal.shop_id     = inv.shop_id
     AND cal.date_seq    = inv.inventory_date
    LEFT JOIN del_agg del
      ON cal.location_id = del.location_id
     AND cal.item_id     = del.item_id
     AND cal.shop_id     = del.shop_id
     AND cal.date_seq    = del.delivery_date
    LEFT JOIN sal_agg sal
      ON cal.location_id = sal.location_id
     AND cal.item_id     = sal.item_id
     AND cal.shop_id     = sal.shop_id
     AND cal.date_seq    = sal.sales_date
),
-- 6) weekly totals (one row per week per combo). inventory = Sunday snapshot (end-of-week),
-- flows = weekly sums; weekdays_with_data used to decide whether to emit weekly total.
weekly_agg AS (
    SELECT
        location_id,
        item_id,
        shop_id,
        week_monday,
        week_monday + 6 AS week_sunday,
        -- Sunday snapshot for inventory (end-of-week)
        MAX(CASE WHEN date_seq = week_monday + 6 THEN inventory_qty END) AS week_inventory,
        -- weekly flows
        SUM(delivery_qty) AS week_delivery,
        SUM(sales_qty)    AS week_sales,
        -- how many Mon-Sat rows had any data (useful to decide whether to show weekly total)
        SUM(CASE WHEN (date_seq - week_monday + 1) BETWEEN 1 AND 6
                 AND (NVL(inventory_qty,0) <> 0 OR NVL(delivery_qty,0) <> 0 OR NVL(sales_qty,0) <> 0)
             THEN 1 ELSE 0 END) AS weekdays_with_data
    FROM daily_data
    GROUP BY location_id, item_id, shop_id, week_monday
),
-- 7) compute forward-4-week averages only on weekly_agg using ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING.
--    This ensures the window moves by weekly rows, not by date range (avoids the daily-row problem).
weekly_with_avg AS (
    SELECT
        w.*,
        AVG(week_inventory) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS avg_inv_next4,
        AVG(week_delivery) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS avg_del_next4,
        AVG(week_sales) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS avg_sales_next4,
        COUNT(*) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS weeks_ahead_count
    FROM weekly_agg w
),
-- 8) combined: daily rows + weekly rows (weekly rows pulled from weekly_with_avg; we only emit weekly rows where weekdays_with_data > 0)
combined AS (
    -- daily detail rows (no 4-week averages)
    SELECT
        location_id,
        item_id,
        shop_id,
        date_seq,
        date_key,
        day_of_week,
        inventory_qty,
        delivery_qty,
        sales_qty,
        day_result,
        NULL AS weekly_total_flag,
        week_monday,
        (date_seq - week_monday + 1) AS day_pos,
        NULL         AS inventory_qty_4_weeks,
        NULL         AS delivery_qty_4_weeks,
        NULL         AS sales_qty_4_weeks
    FROM daily_data
    UNION ALL
    -- weekly total rows, with forward-4-week averages populated only when at least 4 weeks exist ahead
    SELECT
        w.location_id,
        w.item_id,
        w.shop_id,
        w.week_sunday   AS date_seq,
        TO_CHAR(w.week_sunday,'YYYYMMDD') AS date_key,
        'Weekly Total'  AS day_of_week,
        w.week_inventory AS inventory_qty,
        w.week_delivery  AS delivery_qty,
        w.week_sales     AS sales_qty,
        NULL             AS day_result,
        'Y'              AS weekly_total_flag,
        w.week_monday,
        8                AS day_pos,
        CASE WHEN w.weeks_ahead_count >= 4 THEN w.avg_inv_next4 ELSE NULL END AS inventory_qty_4_weeks,
        CASE WHEN w.weeks_ahead_count >= 4 THEN w.avg_del_next4 ELSE NULL END AS delivery_qty_4_weeks,
        CASE WHEN w.weeks_ahead_count >= 4 THEN w.avg_sales_next4 ELSE NULL END AS sales_qty_4_weeks
    FROM weekly_with_avg w
    WHERE w.weekdays_with_data > 0
)
-- final output ordered so weekly total appears after Sunday
SELECT *
FROM combined
ORDER BY location_id, item_id, shop_id, week_monday, day_pos, date_seq;












WITH
-- 1) combos of shop/location/item
combos AS (
    SELECT DISTINCT location_id, item_id, shop_id
    FROM (
        SELECT location_id, item_id, shop_id FROM delivery_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM sales_table
    )
),
-- 2) calendar dates
dates AS (
    SELECT date_seq
    FROM date_table
    WHERE date_seq BETWEEN DATE '2025-08-01' AND DATE '2025-09-01'
),
-- 3) full calendar per combo
calendar AS (
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           d.date_seq
    FROM combos c
    CROSS JOIN dates d
),
-- 4) aggregate deliveries
del_agg AS (
    SELECT location_id, item_id, shop_id, delivery_date, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id, shop_id, delivery_date
),
-- 5) aggregate sales
sal_agg AS (
    SELECT location_id, item_id, shop_id, sales_date, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id, shop_id, sales_date
),
-- 6) daily data with NVL
daily_data AS (
    SELECT
        cal.location_id,
        cal.item_id,
        cal.shop_id,
        cal.date_seq,
        NVL(del.delivery_qty, 0) AS delivery_qty,
        NVL(sal.sales_qty, 0)    AS sales_qty
    FROM calendar cal
    LEFT JOIN del_agg del
      ON cal.location_id = del.location_id
     AND cal.item_id     = del.item_id
     AND cal.shop_id     = del.shop_id
     AND cal.date_seq    = del.delivery_date
    LEFT JOIN sal_agg sal
      ON cal.location_id = sal.location_id
     AND cal.item_id     = sal.item_id
     AND cal.shop_id     = sal.shop_id
     AND cal.date_seq    = sal.sales_date
),
-- 7) rolling 28-day averages
rolling AS (
    SELECT
        d.location_id,
        d.item_id,
        d.shop_id,
        d.date_seq,
        d.delivery_qty,
        d.sales_qty,
        SUM(d.delivery_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_delivery_28d,
        SUM(d.sales_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_sales_28d,
        COUNT(*) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS cnt_28d
    FROM daily_data d
),
-- 8) average past 28 days
avg_data AS (
    SELECT
        r.*,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_delivery_28d / r.cnt_28d ELSE 0 END AS avg_delivery_28d,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_sales_28d / r.cnt_28d ELSE 0 END AS avg_sales_28d
    FROM rolling r
),
-- 9) total per location/item/date
totals AS (
    SELECT
        a.date_seq,
        a.location_id,
        a.item_id,
        SUM(a.delivery_qty) AS total_delivery_qty,
        SUM(a.avg_delivery_28d) AS total_avg_delivery_28d,
        SUM(a.avg_sales_28d) AS total_avg_sales_28d
    FROM avg_data a
    GROUP BY a.date_seq, a.location_id, a.item_id
),
-- 10) join to compute proportions and initial fixed allocation
proportions AS (
    SELECT
        a.location_id,
        a.item_id,
        a.shop_id,
        a.date_seq,
        a.delivery_qty,
        a.sales_qty,
        a.avg_delivery_28d,
        a.avg_sales_28d,
        t.total_delivery_qty,
        t.total_avg_delivery_28d,
        t.total_avg_sales_28d,
        CASE WHEN t.total_avg_delivery_28d = 0 THEN 0
             ELSE round(a.avg_delivery_28d / t.total_avg_delivery_28d, 4) END AS avg_delivery_28d_proportion,
        CASE WHEN t.total_avg_sales_28d = 0 THEN 0
             ELSE round(a.avg_sales_28d / t.total_avg_sales_28d, 4) END AS avg_sales_28d_proportion,
        ROUND(t.total_delivery_qty *
             CASE WHEN t.total_avg_delivery_28d = 0 THEN 1.0 / COUNT(*) OVER (PARTITION BY a.location_id, a.item_id, a.date_seq)
                  ELSE a.avg_delivery_28d / t.total_avg_delivery_28d END
        ) AS fixed_delivery_qty_base
    FROM avg_data a
    JOIN totals t
      ON a.location_id = t.location_id
     AND a.item_id     = t.item_id
     AND a.date_seq    = t.date_seq
),
-- 11) adjust rounding differences
adjusted AS (
    SELECT
        p.*,
        SUM(p.fixed_delivery_qty_base) OVER (PARTITION BY p.location_id, p.item_id, p.date_seq) AS sum_fixed_base,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion DESC) AS rn_desc,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion ASC) AS rn_asc
    FROM proportions p
)
-- 12) final fixed delivery qty with adjustment
SELECT
    a.location_id,
    a.item_id,
    a.shop_id,
    a.date_seq,
    a.delivery_qty,
    a.sales_qty,
    a.avg_delivery_28d,
    a.avg_sales_28d,
    a.avg_delivery_28d_proportion,
    a.avg_sales_28d_proportion,
    a.total_delivery_qty,
    a.sum_fixed_base,
    a.fixed_delivery_qty_base,
CASE
    WHEN a.total_delivery_qty = a.sum_fixed_base THEN a.fixed_delivery_qty_base
    WHEN a.total_delivery_qty > a.sum_fixed_base AND a.rn_desc = 1 THEN a.fixed_delivery_qty_base + (a.total_delivery_qty - a.sum_fixed_base)
    WHEN a.total_delivery_qty < a.sum_fixed_base AND a.rn_asc = 1 THEN a.fixed_delivery_qty_base - (a.sum_fixed_base - a.total_delivery_qty)
    ELSE a.fixed_delivery_qty_base
END AS fixed_delivery_qty
FROM adjusted a
ORDER BY a.location_id, a.item_id, a.shop_id, a.date_seq;






WITH
-- 1) combos of shop/location/item
combos AS (
    SELECT DISTINCT location_id, item_id, shop_id
    FROM (
        SELECT location_id, item_id, shop_id FROM delivery_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM sales_table
    ) t
),
-- 2) calendar dates
dates AS (
    SELECT date_seq
    FROM date_table
    WHERE date_seq BETWEEN DATE '2025-08-01' AND DATE '2025-09-01'
),
-- 3) full calendar per combo
calendar AS (
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           d.date_seq
    FROM combos c
    CROSS JOIN dates d
),
-- 4) aggregate deliveries
del_agg AS (
    SELECT location_id, item_id, shop_id, delivery_date, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id, shop_id, delivery_date
),
-- 5) aggregate sales
sal_agg AS (
    SELECT location_id, item_id, shop_id, sales_date, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id, shop_id, sales_date
),
-- 6) daily data with NVL
daily_data AS (
    SELECT
        cal.location_id,
        cal.item_id,
        cal.shop_id,
        cal.date_seq,
        NVL(del.delivery_qty, 0) AS delivery_qty,
        NVL(sal.sales_qty, 0) AS sales_qty
    FROM calendar cal
    LEFT JOIN del_agg del
      ON cal.location_id = del.location_id
     AND cal.item_id = del.item_id
     AND cal.shop_id = del.shop_id
     AND cal.date_seq = del.delivery_date
    LEFT JOIN sal_agg sal
      ON cal.location_id = sal.location_id
     AND cal.item_id = sal.item_id
     AND cal.shop_id = sal.shop_id
     AND cal.date_seq = sal.sales_date
),
-- 7) rolling 28-day sums and counts (efficient analytic calculation)
rolling AS (
    SELECT
        d.location_id,
        d.item_id,
        d.shop_id,
        d.date_seq,
        d.delivery_qty,
        d.sales_qty,
        SUM(d.delivery_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_delivery_28d,
        SUM(d.sales_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_sales_28d,
        COUNT(*) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS cnt_28d
    FROM daily_data d
),
-- 8) average past 28 days
avg_data AS (
    SELECT
        r.location_id,
        r.item_id,
        r.shop_id,
        r.date_seq,
        r.delivery_qty,
        r.sales_qty,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_delivery_28d / r.cnt_28d ELSE 0 END AS avg_delivery_28d,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_sales_28d / r.cnt_28d ELSE 0 END AS avg_sales_28d
    FROM rolling r
),
-- 9) total per location/item/date
totals AS (
    SELECT
        a.date_seq,
        a.location_id,
        a.item_id,
        SUM(a.delivery_qty) AS total_delivery_qty,
        SUM(a.avg_delivery_28d) AS total_avg_delivery_28d,
        SUM(a.avg_sales_28d) AS total_avg_sales_28d
    FROM avg_data a
    GROUP BY a.date_seq, a.location_id, a.item_id
),
-- 10) join to compute proportions and initial fixed allocation
proportions AS (
    SELECT
        a.location_id,
        a.item_id,
        a.shop_id,
        a.date_seq,
        a.delivery_qty,
        a.sales_qty,
        a.avg_delivery_28d,
        a.avg_sales_28d,
        t.total_delivery_qty,
        t.total_avg_delivery_28d,
        t.total_avg_sales_28d,
        CASE WHEN t.total_avg_delivery_28d = 0 THEN 0
             ELSE round(a.avg_delivery_28d / t.total_avg_delivery_28d, 4) END AS avg_delivery_28d_proportion,
        CASE WHEN t.total_avg_sales_28d = 0 THEN 0
             ELSE round(a.avg_sales_28d / t.total_avg_sales_28d, 4) END AS avg_sales_28d_proportion,
        ROUND(t.total_delivery_qty *
             CASE WHEN t.total_avg_delivery_28d = 0 THEN 1.0 / COUNT(*) OVER (PARTITION BY a.location_id, a.item_id, a.date_seq)
                  ELSE a.avg_delivery_28d / t.total_avg_delivery_28d END
        ) AS fixed_delivery_qty_base
    FROM avg_data a
    JOIN totals t
      ON a.location_id = t.location_id
     AND a.item_id = t.item_id
     AND a.date_seq = t.date_seq
),
-- 11) adjust rounding differences
adjusted AS (
    SELECT
        p.*,
        SUM(p.fixed_delivery_qty_base) OVER (PARTITION BY p.location_id, p.item_id, p.date_seq) AS sum_fixed_base,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion DESC) AS rn_desc,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion ASC) AS rn_asc
    FROM proportions p
)
-- 12) final fixed delivery qty with adjustment
SELECT
    a.location_id,
    a.item_id,
    a.shop_id,
    a.date_seq,
    a.delivery_qty,
    a.sales_qty,
    a.avg_delivery_28d,
    a.avg_sales_28d,
    a.avg_delivery_28d_proportion,
    a.avg_sales_28d_proportion,
    a.total_delivery_qty,
    a.sum_fixed_base,
    a.fixed_delivery_qty_base,
    CASE
        WHEN a.total_delivery_qty = a.sum_fixed_base THEN a.fixed_delivery_qty_base
        WHEN a.total_delivery_qty > a.sum_fixed_base AND a.rn_desc = 1 THEN a.fixed_delivery_qty_base + (a.total_delivery_qty - a.sum_fixed_base)
        WHEN a.total_delivery_qty < a.sum_fixed_base AND a.rn_asc = 1 THEN a.fixed_delivery_qty_base - (a.sum_fixed_base - a.total_delivery_qty)
        ELSE a.fixed_delivery_qty_base
    END AS fixed_delivery_qty
FROM adjusted a
ORDER BY a.location_id, a.item_id, a.shop_id, a.date_seq;























WITH
-- 1) sales per shop on given day
day_sum_result AS (
    SELECT LOCATION_ID, ITEM_ID, SHOP_ID, SUM(SALES_QTY) AS DAY_SUM_QTY
    FROM SALES_TABLE
    WHERE SALES_DATE = DATE '2025-08-08'
      AND ITEM_ID = 'MacBook'
    GROUP BY LOCATION_ID, ITEM_ID, SHOP_ID
),
-- 2) total sales per item/location
shop_sum_result AS (
    SELECT LOCATION_ID, ITEM_ID, SHOP_ID, DAY_SUM_QTY,
           SUM(DAY_SUM_QTY) OVER (PARTITION BY LOCATION_ID, ITEM_ID) AS shop_sum_qty
    FROM day_sum_result
),
-- 3) ratio per shop
shop_ratio AS (
    SELECT a.ITEM_ID, a.SHOP_ID,
           ROUND(SUM(a.DAY_SUM_QTY) / SUM(a.SHOP_SUM_QTY), 4) AS ratio
    FROM shop_sum_result a
    GROUP BY a.ITEM_ID, a.SHOP_ID
),
-- 4) join with deliveries and compute base allocations
base_rows AS (
    SELECT A.LOCATION_ID,
           A.ITEM_ID,
           A.SHOP_ID,
           A.DELIVERY_QTY,
           B.RATIO,
           SUM(A.DELIVERY_QTY) OVER (PARTITION BY A.LOCATION_ID, A.ITEM_ID) AS total_delivery_qty,
           ROUND(SUM(A.DELIVERY_QTY) OVER (PARTITION BY A.LOCATION_ID, A.ITEM_ID) * B.RATIO, 0) AS delivery_ratio_qty
    FROM DELIVERY_TABLE A
    JOIN shop_ratio B
      ON A.SHOP_ID = B.SHOP_ID
    WHERE A.DELIVERY_DATE = DATE '2025-08-08'
      AND A.LOCATION_ID = 'loc01'
),
-- 5) compute total vs sum_base
totals AS (
    SELECT location_id, item_id,
           SUM(delivery_ratio_qty) AS sum_fixed_base,
           MAX(total_delivery_qty)  AS total_delivery_qty
    FROM base_rows
    GROUP BY location_id, item_id
),
-- 6) add row numbers for allocation order
ranked AS (
    SELECT b.location_id,
           b.item_id,
           b.shop_id,
           b.delivery_qty,
           b.ratio,
           b.total_delivery_qty AS base_total_delivery_qty,
           b.delivery_ratio_qty,
           t.sum_fixed_base,
           t.total_delivery_qty AS total_delivery_qty,  -- canonical
           ROW_NUMBER() OVER (PARTITION BY b.location_id, b.item_id ORDER BY b.ratio ASC)  AS rn_asc,
           ROW_NUMBER() OVER (PARTITION BY b.location_id, b.item_id ORDER BY b.ratio DESC) AS rn_desc
    FROM base_rows b
    JOIN totals t
      ON b.location_id = t.location_id
     AND b.item_id     = t.item_id
),
-- 7) recursive redistribution of negative difference (only if sum_fixed_base > total_delivery_qty)
adjust_cte (location_id, item_id, shop_id, rn_asc, delivery_ratio_qty, remaining_diff, fixed_qty) AS (
    -- Anchor: smallest ratio (rn_asc = 1)
    SELECT r.location_id,
           r.item_id,
           r.shop_id,
           r.rn_asc,
           r.delivery_ratio_qty,
           (r.sum_fixed_base - r.total_delivery_qty) AS remaining_diff,
           CASE
             WHEN r.delivery_ratio_qty >= (r.sum_fixed_base - r.total_delivery_qty)
             THEN r.delivery_ratio_qty - (r.sum_fixed_base - r.total_delivery_qty)
             ELSE 0
           END AS fixed_qty
    FROM ranked r
    WHERE r.rn_asc = 1
      AND r.sum_fixed_base > r.total_delivery_qty
    UNION ALL
    -- Recursive: next rows absorb the leftover
    SELECT r.location_id,
           r.item_id,
           r.shop_id,
           r.rn_asc,
           r.delivery_ratio_qty,
           GREATEST(a.remaining_diff - r.delivery_ratio_qty, 0) AS remaining_diff,
           CASE
             WHEN a.remaining_diff <= r.delivery_ratio_qty
             THEN r.delivery_ratio_qty - a.remaining_diff
             ELSE 0
           END AS fixed_qty
    FROM ranked r
    JOIN adjust_cte a
      ON r.location_id = a.location_id
     AND r.item_id     = a.item_id
     AND r.rn_asc      = a.rn_asc + 1
)
-- 8) final result
SELECT r.location_id,
       r.item_id,
       r.shop_id,
       r.delivery_qty,
       r.delivery_ratio_qty,
       r.base_total_delivery_qty,
       r.sum_fixed_base,
       CASE
         -- Case 1: sum_fixed_base > total_delivery_qty → use recursive adjusted qty
         WHEN r.sum_fixed_base > r.total_delivery_qty
         THEN COALESCE(a.fixed_qty, r.delivery_ratio_qty)
         -- Case 2: sum_fixed_base < total_delivery_qty → add difference to highest ratio shop
         WHEN r.sum_fixed_base < r.total_delivery_qty AND r.rn_desc = 1
         THEN r.delivery_ratio_qty + (r.total_delivery_qty - r.sum_fixed_base)
         ELSE r.delivery_ratio_qty
       END AS fixed_delivery_qty
FROM ranked r
LEFT JOIN adjust_cte a
  ON r.location_id = a.location_id
 AND r.item_id     = a.item_id
 AND r.shop_id     = a.shop_id
ORDER BY r.location_id, r.item_id, r.rn_asc;




















WITH
day_sum_result AS (
SELECT
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID,
	SUM(SALES_QTY) AS DAY_SUM_QTY
FROM
	SALES_TABLE
WHERE
	SALES_DATE = DATE '2025-08-08'
	AND ITEM_ID = 'MacBook'
GROUP BY
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID
),
shop_sum_result AS (
SELECT
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID,
	DAY_SUM_QTY,
	SUM(DAY_SUM_QTY) OVER (PARTITION BY LOCATION_ID,
	ITEM_ID) AS shop_sum_qty
FROM
	day_sum_result
ORDER BY
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID
),
shop_ratio AS (
SELECT
	a.ITEM_ID,
	a.SHOP_ID,
	round(sum(a.DAY_SUM_QTY) / sum(a.SHOP_SUM_QTY), 2) AS ratio
FROM
	shop_sum_result a
GROUP BY
	a.ITEM_ID,
	a.SHOP_ID
),
ranked AS (
SELECT
	p.*,
	SUM(p.delivery_ratio_qty + 50) OVER (PARTITION BY p.location_id,
	p.item_id) AS sum_fixed_base,
	ROW_NUMBER() OVER (PARTITION BY p.location_id,
	p.item_id
ORDER BY
	p.RATIO DESC) AS rn_desc,
	ROW_NUMBER() OVER (PARTITION BY p.location_id,
	p.item_id
ORDER BY
	p.RATIO ASC) AS rn_asc
FROM
	(
	SELECT
		A.*,
		B.RATIO,
		sum(A.delivery_qty) OVER (PARTITION BY a.location_id,
		b.item_id) AS total_delivery_qty,
		round(sum(A.delivery_qty) OVER (PARTITION BY a.location_id, b.item_id) * b.RATIO, 0) AS delivery_ratio_qty
	FROM
		DELIVERY_TABLE A,
		shop_ratio B
	WHERE
		A.SHOP_ID = B.SHOP_ID
		AND A.DELIVERY_DATE = DATE '2025-08-08'
		AND A.LOCATION_ID = 'loc01'
) p
),
adjust_cte (location_id,
item_id,
shop_id,
rn_asc,
tag,
SUM_FIXED_BASE,
TOTAL_DELIVERY_QTY,
delivery_ratio_qty,
remaining,
remaining_diff,
fixed_qt) AS (
SELECT
	r.LOCATION_ID,
	r.ITEM_ID,
	r.SHOP_ID,
	r.RN_ASC,
	'a' AS tag,
	r.SUM_FIXED_BASE,
	r.TOTAL_DELIVERY_QTY,
	r.DELIVERY_RATIO_QTY,
	r.remaining_diff AS remaining,
	r.remaining_diff - (DELIVERY_RATIO_QTY - fixed_qty) AS remaining_diff,
	r.fixed_qty
FROM
	(
	SELECT
		r.LOCATION_ID,
		r.ITEM_ID,
		r.SHOP_ID,
		r.RN_ASC,
		'a' AS tag,
		r.SUM_FIXED_BASE,
		r.TOTAL_DELIVERY_QTY,
		r.DELIVERY_RATIO_QTY,
		r.SUM_FIXED_BASE - r.TOTAL_DELIVERY_QTY AS remaining_diff,
		CASE
			WHEN r.DELIVERY_RATIO_QTY >= (r.sum_fixed_base - total_delivery_qty)
     THEN r.DELIVERY_RATIO_QTY - (r.sum_fixed_base - total_delivery_qty)
			ELSE 0
		END AS fixed_qty
	FROM
		ranked r
	WHERE
		r.RN_ASC = 1
		AND r.SUM_FIXED_BASE > r.TOTAL_DELIVERY_QTY
) r
UNION ALL
SELECT
	r.LOCATION_ID,
	r.ITEM_ID,
	r.SHOP_ID,
	r.RN_ASC,
	'b' AS tag,
	r.SUM_FIXED_BASE,
	r.TOTAL_DELIVERY_QTY,
	r.DELIVERY_RATIO_QTY,
	a.remaining,
	greatest (a.REMAINING_DIFF - r.DELIVERY_RATIO_QTY,
	0) AS remaining_diff,
	CASE
		WHEN a.REMAINING_DIFF <= r.DELIVERY_RATIO_QTY
     THEN r.DELIVERY_RATIO_QTY - a.REMAINING_DIFF
		ELSE 0
	END AS fixed_qty
FROM
	ranked r,
	adjust_cte a
WHERE
	r.LOCATION_ID = a.LOCATION_ID
	AND r.ITEM_ID = a.ITEM_ID
	AND r.RN_ASC = a.RN_ASC + 1
)
SELECT
	*
FROM
	adjust_cte
WHERE
	ITEM_ID = 'MacBook'



SELECT A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, A.DATE_SEQ, A.DAY_OF_WEEK,
       A.INVENTORY_QTY, B.DELIVERY_QTY, C.SALES_QTY,
       NVL(B.DELIVERY_QTY, 0) - NVL(C.SALES_QTY, 0) AS DAY_RESULT,
       SUM(NVL(A.INVENTORY_QTY, 0) + NVL(B.DELIVERY_QTY, 0) - NVL(C.SALES_QTY, 0)) OVER (PARTITION BY A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID ORDER BY A.DATE_SEQ) AS INVENTORY
FROM (
      SELECT *
      FROM DATE_TABLE A
           LEFT OUTER JOIN INVENTORY_TABLE B PARTITION BY (B.LOCATION_ID, B.ITEM_ID, B.SHOP_ID)
           ON A.DATE_SEQ = B.INVENTORY_DATE
      WHERE A.DATE_SEQ BETWEEN DATE '2025-07-31' AND DATE '2025-10-31'
      ) A,
      DELIVERY_TABLE B,
      SALES_TABLE C
WHERE A.DATE_SEQ = B.DELIVERY_DATE (+)
AND A.LOCATION_ID = B.LOCATION_ID (+)
AND A.ITEM_ID = B.ITEM_ID (+)
AND A.SHOP_ID = B.SHOP_ID (+)
AND A.DATE_SEQ = C.SALES_DATE (+)
AND A.LOCATION_ID = C.LOCATION_ID (+)
AND A.ITEM_ID = C.ITEM_ID (+)
AND A.SHOP_ID = C.SHOP_ID (+)
ORDER BY A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, A.DATE_SEQ


SELECT A.*, SUM(INVENTORY_QTY) OVER (ORDER BY A.SALES_DATE)
FROM (
SELECT A.INVENTORY_DATE AS SALES_DATE, A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, 0 AS SALES_QTY, 0 AS DELIVERY_QTY, A.INVENTORY_QTY 
FROM INVENTORY_TABLE A
WHERE A.LOCATION_ID = 'loc01'
AND A.ITEM_ID = 'iPhone'
AND A.SHOP_ID = 'Costco'
UNION all
SELECT A.SALES_DATE, A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, A.SALES_QTY, B.DELIVERY_QTY, B.DELIVERY_QTY - A.SALES_QTY AS INVENTORY_QTY
FROM SALES_TABLE A, DELIVERY_TABLE B
WHERE A.LOCATION_ID = B.LOCATION_ID
AND A.ITEM_ID = B.ITEM_ID
AND A.SHOP_ID = B.SHOP_ID
AND A.SALES_DATE = B.DELIVERY_DATE
AND A.LOCATION_ID = 'loc01'
AND A.ITEM_ID = 'iPhone'
AND A.SHOP_ID = 'Costco'
) A
--ORDER BY A.SALES_DATE










WITH inv_cte (
    location_id, item_id, sales_date,
    receipts_qty, sales_qty,
    inventory_qty
) AS (
    -- Anchor: earliest sales_date per item
    SELECT t.location_id,
           t.item_id,
           t.sales_date,
           t.receipts_qty,
           t.sales_qty,
           (0 + t.receipts_qty - t.sales_qty) AS inventory_qty
    FROM inventory_txn t
    WHERE (t.location_id, t.item_id, t.sales_date) IN (
        SELECT location_id, item_id, MIN(sales_date)
        FROM inventory_txn
        GROUP BY location_id, item_id
    )
    UNION ALL
    -- Recursive: next closest sales_date
    SELECT t.location_id,
           t.item_id,
           t.sales_date,
           t.receipts_qty,
           t.sales_qty,
           (a.inventory_qty + t.receipts_qty - t.sales_qty) AS inventory_qty
    FROM inv_cte a
    JOIN inventory_txn t
      ON t.location_id = a.location_id
     AND t.item_id     = a.item_id
     AND t.sales_date = (
            SELECT MIN(s2.sales_date)
            FROM inventory_txn s2
            WHERE s2.location_id = a.location_id
              AND s2.item_id     = a.item_id
              AND s2.sales_date  > a.sales_date
       )
)
SEARCH DEPTH FIRST BY sales_date SET seq_col
CYCLE location_id, item_id, sales_date
    SET cycle_mark TO 'Y' DEFAULT 'N'
SELECT location_id,
       item_id,
       sales_date,
       receipts_qty,
       sales_qty,
       inventory_qty,
       seq_col
FROM inv_cte
WHERE cycle_mark = 'N'
ORDER BY location_id, item_id, sales_date;









WITH inv_cte (
    location_id, item_id, sales_date,
    receipts_qty, sales_qty,
    inventory_qty
) AS (
    -- Anchor: earliest sales_date per item
    SELECT t.location_id,
           t.item_id,
           t.sales_date,
           t.receipts_qty,
           t.sales_qty,
           (0 + t.receipts_qty - t.sales_qty) AS inventory_qty
    FROM inventory_txn t
    WHERE (t.location_id, t.item_id, t.sales_date) IN (
        SELECT location_id, item_id, MIN(sales_date)
        FROM inventory_txn
        GROUP BY location_id, item_id
    )
    UNION ALL
    -- Recursive: next closest sales_date
    SELECT t.location_id,
           t.item_id,
           t.sales_date,
           t.receipts_qty,
           t.sales_qty,
           (a.inventory_qty + t.receipts_qty - t.sales_qty) AS inventory_qty
    FROM inv_cte a
    JOIN inventory_txn t
      ON t.location_id = a.location_id
     AND t.item_id     = a.item_id
     AND t.sales_date = (
            SELECT MIN(s2.sales_date)
            FROM inventory_txn s2
            WHERE s2.location_id = a.location_id
              AND s2.item_id     = a.item_id
              AND s2.sales_date  > a.sales_date
       )
)
SEARCH DEPTH FIRST BY sales_date SET seq_col
CYCLE location_id, item_id, sales_date
    SET cycle_mark TO 'Y' DEFAULT 'N'
SELECT location_id,
       item_id,
       sales_date,
       receipts_qty,
       sales_qty,
       inventory_qty,
       seq_col
FROM inv_cte
WHERE cycle_mark = 'N'
ORDER BY location_id, item_id, sales_date;





WITH combos AS (
  -- distinct combos and their date range (ignore NULL keys)
  SELECT location_id,
         item_id,
         MIN(sales_date) AS min_date,
         MAX(sales_date) AS max_date
  FROM inventory_txn
  WHERE location_id IS NOT NULL
    AND item_id     IS NOT NULL
  GROUP BY location_id, item_id
),
nums AS (
  -- number generator up to the largest span across combos
  SELECT LEVEL AS n
  FROM dual
  CONNECT BY LEVEL <= (
    SELECT NVL(MAX(max_date - min_date + 1), 0) FROM combos
  )
),
calendar AS (
  -- expand each combo into every date from min_date .. max_date
  SELECT c.location_id,
         c.item_id,
         c.min_date + (n.n - 1) AS sales_date
  FROM combos c
  JOIN nums n
    ON n.n <= (c.max_date - c.min_date + 1)
),
base AS (
  -- left-join actual transactions so missing days get zeros
  SELECT cal.location_id,
         cal.item_id,
         cal.sales_date,
         NVL(t.receipts_qty, 0) AS receipts_qty,
         NVL(t.sales_qty,   0) AS sales_qty,
         CASE WHEN t.location_id IS NULL THEN 1 ELSE 0 END AS is_blank
  FROM calendar cal
  LEFT JOIN inventory_txn t
    ON t.location_id = cal.location_id
   AND t.item_id     = cal.item_id
   AND t.sales_date  = cal.sales_date
),
first_day AS (
  -- first calendar date per combo (anchor for recursion)
  SELECT location_id, item_id, MIN(sales_date) AS first_date
  FROM base
  GROUP BY location_id, item_id
),
inv_cte (
    location_id, item_id, sales_date,
    receipts_qty, sales_qty,
    inventory_qty
) AS (
  -- anchor: start at each combo's first_date, opening inventory = 0 (change if you have opening stock)
  SELECT b.location_id,
         b.item_id,
         b.sales_date,
         b.receipts_qty,
         b.sales_qty,
         -- apply blank-day penalty when both receipts & sales are zero
         (0 + b.receipts_qty - b.sales_qty
           - CASE WHEN b.receipts_qty = 0 AND b.sales_qty = 0 THEN 10 ELSE 0 END
         ) AS inventory_qty
  FROM base b
  JOIN first_day f
    ON b.location_id = f.location_id
   AND b.item_id     = f.item_id
   AND b.sales_date  = f.first_date
  UNION ALL
  -- recursive: next calendar day for same combo
  SELECT b.location_id,
         b.item_id,
         b.sales_date,
         b.receipts_qty,
         b.sales_qty,
         (a.inventory_qty
           + b.receipts_qty
           - b.sales_qty
           - CASE WHEN b.receipts_qty = 0 AND b.sales_qty = 0 THEN 10 ELSE 0 END
         ) AS inventory_qty
  FROM inv_cte a
  JOIN base b
    ON b.location_id = a.location_id
   AND b.item_id     = a.item_id
   AND b.sales_date  = a.sales_date + 1
)
SELECT location_id,
       item_id,
       sales_date,
       receipts_qty,
       sales_qty,
       inventory_qty
FROM inv_cte
ORDER BY location_id, item_id, sales_date;






WITH combos AS (
  -- distinct combos and their date range (ignore NULL keys)
  SELECT location_id,
         item_id,
         MIN(sales_date) AS min_date,
         MAX(sales_date) AS max_date
  FROM inventory_txn
  WHERE location_id IS NOT NULL
    AND item_id     IS NOT NULL
  GROUP BY location_id, item_id
),
nums AS (
  -- number generator up to the largest span across combos
  SELECT LEVEL AS n
  FROM dual
  CONNECT BY LEVEL <= (
    SELECT NVL(MAX(max_date - min_date + 1), 0) FROM combos
  )
),
calendar AS (
  -- expand each combo into every date from min_date .. max_date
  SELECT c.location_id,
         c.item_id,
         c.min_date + (n.n - 1) AS sales_date
  FROM combos c
  JOIN nums n
    ON n.n <= (c.max_date - c.min_date + 1)
),
base AS (
  -- left-join actual transactions so missing days get zeros
  SELECT cal.location_id,
         cal.item_id,
         cal.sales_date,
         NVL(t.receipts_qty, 0) AS receipts_qty,
         NVL(t.sales_qty,   0) AS sales_qty,
         CASE WHEN t.location_id IS NULL THEN 1 ELSE 0 END AS is_blank
  FROM calendar cal
  LEFT JOIN inventory_txn t
    ON t.location_id = cal.location_id
   AND t.item_id     = cal.item_id
   AND t.sales_date  = cal.sales_date
),
first_day AS (
  -- first calendar date per combo (anchor for recursion)
  SELECT location_id, item_id, MIN(sales_date) AS first_date
  FROM base
  GROUP BY location_id, item_id
),
inv_cte (
    location_id, item_id, sales_date,
    receipts_qty, sales_qty,
    inventory_qty
) AS (
  -- anchor: start at each combo's first_date, opening inventory = 0 (change if you have opening stock)
  SELECT b.location_id,
         b.item_id,
         b.sales_date,
         b.receipts_qty,
         b.sales_qty,
         -- apply blank-day penalty when both receipts & sales are zero
         (0 + b.receipts_qty - b.sales_qty
--           - CASE WHEN b.receipts_qty = 0 AND b.sales_qty = 0 THEN 10 ELSE 0 END
           - CASE WHEN b.is_blank = 1 THEN 10 ELSE 0 END
         ) AS inventory_qty
  FROM base b
  JOIN first_day f
    ON b.location_id = f.location_id
   AND b.item_id     = f.item_id
   AND b.sales_date  = f.first_date
  UNION ALL
  -- recursive: next calendar day for same combo
  SELECT b.location_id,
         b.item_id,
         b.sales_date,
         b.receipts_qty,
         b.sales_qty,
         (a.inventory_qty
           + b.receipts_qty
           - b.sales_qty
--           - CASE WHEN b.receipts_qty = 0 AND b.sales_qty = 0 THEN 10 ELSE 0 END
           - CASE WHEN b.is_blank = 1 THEN 10 ELSE 0 END
         ) AS inventory_qty
  FROM inv_cte a
  JOIN base b
    ON b.location_id = a.location_id
   AND b.item_id     = a.item_id
   AND b.sales_date  = a.sales_date + 1
)
SELECT location_id,
       item_id,
       sales_date,
       receipts_qty,
       sales_qty,
       inventory_qty
FROM inv_cte
ORDER BY location_id, item_id, sales_date;



CREATE TABLE inventory_txn (
    location_id   VARCHAR2(20),
    item_id       VARCHAR2(20),
    sales_date    DATE,
    receipts_qty  NUMBER,
    sales_qty     NUMBER
);






WITH base AS (
    -- combine deliveries and sales per day per product
    SELECT d.location_id,
           d.item_id,
           d.shop_id,
           d.delivery_date AS tx_date,
           NVL(SUM(d.delivery_qty), 0) AS delivery_qty,
           0 AS sales_qty
    FROM delivery_table d
    WHERE d.delivery_date >= DATE '2025-09-01'
    GROUP BY d.location_id, d.item_id, d.shop_id, d.delivery_date
    UNION ALL
    SELECT s.location_id,
           s.item_id,
           s.shop_id,
           s.sales_date AS tx_date,
           0 AS delivery_qty,
           NVL(SUM(s.sales_qty), 0) AS sales_qty
    FROM sales_table s
    WHERE s.sales_date >= DATE '2025-09-01'
    GROUP BY s.location_id, s.item_id, s.shop_id, s.sales_date
),
calendar AS (
    -- list all distinct (loc,item,shop) that appear in September
    SELECT DISTINCT location_id, item_id, shop_id
    FROM base
),
anchors AS (
    -- get August 31 inventory
    SELECT i.location_id,
           i.item_id,
           i.shop_id,
           DATE '2025-08-31' AS tx_date,
           0 AS delivery_qty,
           0 AS sales_qty,
           i.inventory_qty AS inventory_qty
    FROM inventory_table i
    UNION ALL
    -- add missing items (new ones) with zero opening inventory
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           DATE '2025-08-31' AS tx_date,
           0, 0, 0
    FROM calendar c
    WHERE NOT EXISTS (
        SELECT 1
        FROM inventory_table i
        WHERE i.location_id = c.location_id
          AND i.item_id     = c.item_id
          AND i.shop_id     = c.shop_id
    )
),
merged AS (
    -- join deliveries and sales together
    SELECT b.location_id,
           b.item_id,
           b.shop_id,
           b.tx_date,
           SUM(b.delivery_qty) AS delivery_qty,
           SUM(b.sales_qty)    AS sales_qty,
           0                   AS inventory_qty
    FROM base b
    GROUP BY b.location_id, b.item_id, b.shop_id, b.tx_date
),
all_days AS (
    SELECT * FROM anchors
    UNION ALL
    SELECT * FROM merged
),
inv_cte (
    location_id,
    item_id,
    shop_id,
    tx_date,
    delivery_qty,
    sales_qty,
    inventory_qty
) AS (
    -- anchor: Aug 31
    SELECT a.location_id,
           a.item_id,
           a.shop_id,
           a.tx_date,
           a.delivery_qty,
           a.sales_qty,
           a.inventory_qty
    FROM anchors a
    UNION ALL
    -- recursive: next day inventory
    SELECT b.location_id,
           b.item_id,
           b.shop_id,
           b.tx_date,
           b.delivery_qty,
           b.sales_qty,
           (a.inventory_qty + b.delivery_qty - b.sales_qty) AS inventory_qty
    FROM inv_cte a
    JOIN all_days b
      ON b.location_id = a.location_id
     AND b.item_id     = a.item_id
     AND b.shop_id     = a.shop_id
     AND b.tx_date     = a.tx_date + 1
)
SELECT *
FROM inv_cte
WHERE location_id = 'loc01'
AND SHOP_ID = 'BestBuy'
AND TX_DATE < DATE '2025-09-02'
ORDER BY location_id, item_id, shop_id, tx_date;





SELECT
    COALESCE(a.id, b.id, c.id) AS common_id,
    a.col_a,
    b.col_b,
    c.col_c
FROM
    TableA a
FULL OUTER JOIN
    TableB b ON a.id = b.id
FULL OUTER JOIN
    TableC c ON COALESCE(a.id, b.id) = c.id;











WITH d AS (
  SELECT LOCATION_ID, ITEM_ID, SHOP_ID, QTY, STATUS, DATE_DELIVERED
  FROM DELIVERY_TABLE
)
SELECT
    a.LOCATION_ID,
    a.ITEM_ID,
    a.SHOP_ID,
    (SELECT QTY FROM d 
      WHERE d.LOCATION_ID = a.LOCATION_ID
        AND d.ITEM_ID = a.ITEM_ID
        AND d.SHOP_ID = a.SHOP_ID) AS QTY,
    (SELECT STATUS FROM d 
      WHERE d.LOCATION_ID = a.LOCATION_ID
        AND d.ITEM_ID = a.ITEM_ID
        AND d.SHOP_ID = a.SHOP_ID) AS STATUS,
    (SELECT DATE_DELIVERED FROM d 
      WHERE d.LOCATION_ID = a.LOCATION_ID
        AND d.ITEM_ID = a.ITEM_ID
        AND d.SHOP_ID = a.SHOP_ID) AS DATE_DELIVERED
FROM INVENTORY_TABLE a;


















WITH /*+ MATERIALIZE */ sales_agg AS (
    SELECT location_id, item_id, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id
),
/*+ MATERIALIZE */ delivery_agg AS (
    SELECT location_id, item_id, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id
),
/*+ MATERIALIZE */ inventory_agg AS (
    SELECT location_id, item_id, MAX(inventory_qty) AS inventory_qty
    FROM inventory_table
    GROUP BY location_id, item_id
)
SELECT /*+ LEADING(s d i) USE_HASH(d) USE_NL(i) */
       s.location_id,
       s.item_id,
       NVL(i.inventory_qty,0)
         + NVL(d.delivery_qty,0)
         - NVL(s.sales_qty,0) AS end_inventory
FROM sales_agg s
LEFT JOIN delivery_agg d ON s.location_id = d.location_id AND s.item_id = d.item_id
LEFT JOIN inventory_agg i ON s.location_id = i.location_id AND s.item_id = i.item_id;



SELECT /*+ LEADING(s d i) USE_HASH(d) USE_NL(i) */
       s.location_id, s.item_id, s.sales_qty, d.delivery_qty, i.inventory_qty
FROM sales_agg s
LEFT JOIN delivery_agg d ON ...
LEFT JOIN inventory_agg i ON ...;



| Hint                     | Behavior                               | Typical Use                 |
| ------------------------ | -------------------------------------- | --------------------------- |
| `/*+ MATERIALIZE */`     | Forces Oracle to compute and store CTE | Reused or large CTEs        |
| `/*+ INLINE */`          | Forces Oracle to inline the CTE        | Single-use small CTEs       |
| `/*+ USE_NL(alias) */`   | Nested Loop join                       | Small indexed tables        |
| `/*+ USE_HASH(alias) */` | Hash join                              | Large unindexed tables      |
| `/*+ LEADING(a b c) */`  | Fix join order                         | Prevents bad optimizer plan |


| Hint                     | Meaning            | Use when                                     |
| ------------------------ | ------------------ | -------------------------------------------- |
| `USE_NL(table_alias)`    | Nested Loop join   | Small dataset on right side, good indexes    |
| `USE_HASH(table_alias)`  | Hash Join          | Large datasets, memory is available          |
| `USE_MERGE(table_alias)` | Sort-Merge Join    | Both sides large, and join keys are sorted   |
| `LEADING(a b c)`         | Control join order | When Oracle picks a poor order automatically |





SELECT *
FROM customers
WHERE NVL(customer_name, 'NULL_FLAG') = 'NULL_FLAG';




| Situation                             | Example hint             | Why it helps                |
| ------------------------------------- | ------------------------ | --------------------------- |
| Oracle chooses wrong join order       | `LEADING(table1 table2)` | Force correct driving table |
| Oracle picks a slow join type         | `USE_HASH`, `USE_MERGE`  | Control join algorithm      |
| You need to avoid index for full scan | `FULL(table1)`           | Override bad index usage    |
| You want parallel execution           | `PARALLEL(table1, 4)`    | Speed up big queries        |
| You’re tuning a complex view or CTE   | `MATERIALIZE`, `INLINE`  | Control subquery evaluation |


SELECT /*+ USE_HASH(a b c d e f) PARALLEL(4) */
...

SELECT /*+ LEADING(a) USE_HASH(b c d e f) */



SELECT * FROM v$lock WHERE block > 0;
SELECT sid, event, p1text, p2text, p3text, wait_time, seconds_in_wait
FROM v$session
WHERE wait_class != 'Idle';

--enq: TX - row lock contention
--buffer busy waits
--log file sync



ALTER SESSION ENABLE PARALLEL DML;

INSERT /*+ APPEND PARALLEL(big_table 8) PARALLEL(target_table 8) */ INTO target_table
SELECT col1, col2, SUM(col3)
FROM big_table
GROUP BY col1, col2;
COMMIT;


INSERT INTO temp_stage
SELECT col1, col2, SUM(col3)
FROM big_table
GROUP BY col1, col2;

INSERT INTO target_table
SELECT * FROM temp_stage;


SELECT * FROM v$sql
WHERE sql_text LIKE '%/* test query */%'

SELECT * FROM v$sql_plan WHERE sql_id = '4a73s0scm16mr'

SELECT * FROM
table(dbms_xplan.display_cursor('4a73s0scm16mr'))


SELECT * FROM v$sqlarea;
SELECT * FROM v$sqlstats;
SELECT * FROM v$sql;
SELECT * FROM v$sql_plan;
SELECT * FROM v$sql_workarea;
SELECT * FROM v$sql_plan_statistics;
SELECT * FROM v$sql_plan_statistics_all;
 
 SELECT s.prod_id
  FROM sales s, customers c
  WHERE s.cust_id = c.cust_id;
 
select * from v$sql;
select * from v$sql where sql_text like '%SELECT s.prod_id 
                                           FROM sales s, customers c 
                                           WHERE s.cust_id = c.cust_id%';
select * from v$sql where sql_text like '%SELECT s.prod_id FROM sales s, customers c WHERE s.cust_id = c.cust_id%';
 
 SELECT /* my query */ s.prod_id
  FROM sales s, customers c
  WHERE s.cust_id = c.cust_id;
 
select * from v$sql where sql_text like '%my query%';
select * from v$sql_plan where sql_id = '';
select * from table(dbms_xplan.display_cursor(''));




DECLARE
  v_start NUMBER;
  v_end   NUMBER;
BEGIN
  v_start := DBMS_UTILITY.get_time;  -- time in 1/100ths of a second

  -- your query here
  FOR r IN (SELECT /*+ FULL(your_table) */ * FROM your_table WHERE your_condition) LOOP
    NULL;
  END LOOP;

  v_end := DBMS_UTILITY.get_time;
  DBMS_OUTPUT.put_line('Elapsed time: ' || TO_CHAR((v_end - v_start)/100) || ' seconds');
END;



SELECT index_name, status
FROM user_indexes
WHERE table_name = 'SALES';

INDEX_NAME           STATUS
-------------------- --------
SALES_IDX_CUSTOMER   UNUSABLE
SALES_IDX_DATE       UNUSABLE



-- Detect if a session is waiting
SELECT
    s.sid,
    s.serial#,
    s.username,
    s.status,
    s.event,
    s.wait_class,
    s.seconds_in_wait,
    s.state,
    s.sql_id,
    s.program
FROM v$session s
WHERE s.username IS NOT NULL
  AND s.status = 'ACTIVE'
ORDER BY s.seconds_in_wait DESC;


-- See what SQL is actually running
SELECT sql_text
FROM v$sql
WHERE sql_id = '&&sql_id';


-- Check if it’s waiting on locks (very common)
SELECT
    l1.sid AS waiting_session,
    s1.username AS waiting_user,
    l2.sid AS blocking_session,
    s2.username AS blocking_user,
    l1.id1, l1.id2, l1.lmode, l1.request
FROM v$lock l1
JOIN v$lock l2
  ON l1.id1 = l2.id1 AND l1.id2 = l2.id2
JOIN v$session s1 ON l1.sid = s1.sid
JOIN v$session s2 ON l2.sid = s2.sid
WHERE l1.block = 0 AND l2.block = 1;


-- Optional: see the overall wait breakdown
SELECT event, total_waits, time_waited, average_wait
FROM v$system_event
WHERE wait_class <> 'Idle'
ORDER BY time_waited DESC;


-- Check blocking objects (what table or row?)
SELECT
    s.sid,
    s.serial#,
    s.username,
    o.object_name,
    o.object_type
FROM v$session s
JOIN v$locked_object lo ON s.sid = lo.session_id
JOIN all_objects o ON lo.object_id = o.object_id;


-- (Optional) — Use V$ACTIVE_SESSION_HISTORY (if you have the Diagnostic Pack)
SELECT sample_time, session_id, session_state, event, wait_class, sql_id
FROM v$active_session_history
WHERE session_id = 288
ORDER BY sample_time DESC;


-- Tip: To find your current session
SELECT sid, serial#, username, program
FROM v$session
WHERE audsid = USERENV('SESSIONID');


Summary
Purpose	View / Query
Check current waits	v$session
Find blocking sessions	v$lock, v$session
See SQL causing delay	v$sql
Check which object is locked	v$locked_object, all_objects
Historical wait analysis	v$active_session_history (Diag. Pack)




