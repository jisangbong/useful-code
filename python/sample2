

CREATE OR REPLACE PROCEDURE load_performance IS
    -- Cursor for departments
    CURSOR dept_cur IS
        SELECT deptno
        FROM dept;

    -- Cursor for employees in a department
    CURSOR emp_cur(p_deptno dept.deptno%TYPE) IS
        SELECT empno
        FROM emp
        WHERE deptno = p_deptno;

    -- Cursor for sales by employee, grouped by date
    CURSOR sales_cur(p_empno emp.empno%TYPE) IS
        SELECT sale_date,
               SUM(sales_amount) AS total_sales
        FROM sales
        WHERE empno = p_empno
        GROUP BY sale_date;
BEGIN
    -- Loop through departments
    FOR d IN dept_cur LOOP
        -- Loop through employees in each department
        FOR e IN emp_cur(d.deptno) LOOP
            -- Loop through sales totals for each employee
            FOR s IN sales_cur(e.empno) LOOP
                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (d.deptno, e.empno, s.sale_date, s.total_sales);
            END LOOP;
        END LOOP;
    END LOOP;

    COMMIT;
END load_performance;




CREATE OR REPLACE PROCEDURE update_emp_performance_bulk IS
    -- Record type for employee updates
    TYPE emp_perf_rec IS RECORD (
        empno      emp.empno%TYPE,
        total_perf NUMBER
    );

    -- Table type for bulk processing
    TYPE emp_perf_tab IS TABLE OF emp_perf_rec;
    l_emp_perf emp_perf_tab;

    -- Cursor for batching
    CURSOR c_perf IS
        SELECT empno, SUM(total_sales) AS total_perf
        FROM performance
        GROUP BY empno;

    l_limit CONSTANT PLS_INTEGER := 10000;  -- chunk size
    l_count PLS_INTEGER := 0;
BEGIN
    OPEN c_perf;
    LOOP
        FETCH c_perf BULK COLLECT INTO l_emp_perf LIMIT l_limit;
        EXIT WHEN l_emp_perf.COUNT = 0;

        -- Bulk update EMP using FORALL
        FORALL i IN 1 .. l_emp_perf.COUNT
            UPDATE emp
            SET performance = l_emp_perf(i).total_perf
            WHERE empno = l_emp_perf(i).empno;

        COMMIT;  -- commit after each chunk
        l_count := l_count + l_emp_perf.COUNT;
        DBMS_OUTPUT.PUT_LINE('Updated ' || l_count || ' rows so far...');
    END LOOP;

    CLOSE c_perf;
    DBMS_OUTPUT.PUT_LINE('All EMP rows updated successfully.');
END update_emp_performance_bulk;
/


CREATE OR REPLACE PROCEDURE load_performance IS
BEGIN
    -- Loop over departments
    FOR d IN (SELECT deptno FROM dept) LOOP
        -- Loop over employees in each department
        FOR e IN (SELECT empno FROM emp WHERE deptno = d.deptno) LOOP
            -- Loop over sales totals by date for each employee
            FOR s IN (SELECT sale_date,
                             SUM(sales_amount) AS total_sales
                      FROM sales
                      WHERE empno = e.empno
                      GROUP BY sale_date) LOOP

                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (d.deptno, e.empno, s.sale_date, s.total_sales);

            END LOOP;
        END LOOP;
    END LOOP;

    COMMIT;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    c_dept   SYS_REFCURSOR;
    c_emp    SYS_REFCURSOR;
    c_sales  SYS_REFCURSOR;

    v_deptno dept.deptno%TYPE;
    v_empno  emp.empno%TYPE;
    v_date   sales.sale_date%TYPE;
    v_total  NUMBER;
BEGIN
    OPEN c_dept FOR SELECT deptno FROM dept;
    LOOP
        FETCH c_dept INTO v_deptno; EXIT WHEN c_dept%NOTFOUND;

        OPEN c_emp FOR SELECT empno FROM emp WHERE deptno = v_deptno;
        LOOP
            FETCH c_emp INTO v_empno; EXIT WHEN c_emp%NOTFOUND;

            OPEN c_sales FOR
                SELECT sale_date, SUM(sales_amount)
                FROM sales
                WHERE empno = v_empno
                GROUP BY sale_date;

            LOOP
                FETCH c_sales INTO v_date, v_total; EXIT WHEN c_sales%NOTFOUND;

                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (v_deptno, v_empno, v_date, v_total);

            END LOOP;
            CLOSE c_sales;
        END LOOP;
        CLOSE c_emp;
    END LOOP;
    CLOSE c_dept;

    COMMIT;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    v_count PLS_INTEGER := 0;
BEGIN
    -- Loop over departments
    FOR d IN (SELECT deptno FROM dept) LOOP
        -- Loop over employees in each department
        FOR e IN (SELECT empno FROM emp WHERE deptno = d.deptno) LOOP
            -- Loop over sales totals by date for each employee
            FOR s IN (SELECT sale_date,
                             SUM(sales_amount) AS total_sales
                      FROM sales
                      WHERE empno = e.empno
                      GROUP BY sale_date) LOOP

                INSERT INTO performance (deptno, empno, sale_date, total_sales)
                VALUES (d.deptno, e.empno, s.sale_date, s.total_sales);

                v_count := v_count + 1;

                -- Commit every 10,000 rows
                IF MOD(v_count, 10000) = 0 THEN
                    COMMIT;
                END IF;

            END LOOP;
        END LOOP;
    END LOOP;

    -- Final commit for leftovers
    COMMIT;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    TYPE perf_tab IS TABLE OF performance%ROWTYPE;
    l_data perf_tab;
BEGIN
    -- Fetch everything in one SELECT
    SELECT e.deptno, s.empno, s.sale_date, SUM(s.sales_amount)
    BULK COLLECT INTO l_data
    FROM emp e
         JOIN sales s ON e.empno = s.empno
         JOIN dept d  ON e.deptno = d.deptno
    GROUP BY e.deptno, s.empno, s.sale_date;

    -- Insert in chunks of 10,000
    FOR i IN 1 .. CEIL(l_data.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_data.COUNT)
            INSERT INTO performance VALUES l_data(j);
        COMMIT;
    END LOOP;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    TYPE perf_tab IS TABLE OF performance%ROWTYPE;
    l_data perf_tab;
BEGIN
    -- Collect everything with one query
    SELECT e.deptno, s.empno, s.sale_date, SUM(s.sales_amount)
    BULK COLLECT INTO l_data
    FROM   emp e
           JOIN sales s ON e.empno = s.empno
           JOIN dept d  ON e.deptno = d.deptno
    GROUP  BY e.deptno, s.empno, s.sale_date;

    -- Insert in chunks of 10,000
    FOR i IN 1 .. CEIL(l_data.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_data.COUNT)
            INSERT INTO performance VALUES l_data(j);
        COMMIT;
    END LOOP;
END load_performance;
/


CREATE OR REPLACE PROCEDURE load_performance IS
    -- Custom record type matching the 4 columns we insert
    TYPE perf_rec IS RECORD (
        deptno      performance.deptno%TYPE,
        empno       performance.empno%TYPE,
        sale_date   performance.sale_date%TYPE,
        total_sales performance.total_sales%TYPE
    );

    -- Table type for bulk processing
    TYPE perf_tab IS TABLE OF perf_rec;
    l_data perf_tab;
BEGIN
    -- Bulk collect from sales aggregation
    SELECT e.deptno,
           s.empno,
           s.sale_date,
           SUM(s.sales_amount)
    BULK COLLECT INTO l_data
    FROM   emp e
           JOIN sales s ON e.empno = s.empno
           JOIN dept d  ON e.deptno = d.deptno
    GROUP  BY e.deptno, s.empno, s.sale_date;

    -- Insert in chunks of 10,000 rows
    FOR i IN 1 .. CEIL(l_data.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_data.COUNT)
            INSERT INTO performance (deptno, empno, sale_date, total_sales)
            VALUES (l_data(j).deptno,
                    l_data(j).empno,
                    l_data(j).sale_date,
                    l_data(j).total_sales);

        COMMIT;
    END LOOP;
END load_performance;




CREATE OR REPLACE PROCEDURE load_and_update_performance IS
    -- Type for bulk collecting performance inserts
    TYPE perf_rec IS RECORD (
        deptno      performance.deptno%TYPE,
        empno       performance.empno%TYPE,
        sale_date   performance.sale_date%TYPE,
        total_sales performance.total_sales%TYPE
    );

    TYPE perf_tab IS TABLE OF perf_rec;
    l_perf perf_tab;

    -- Type for updating EMP.performance
    TYPE emp_perf_rec IS RECORD (
        empno       emp.empno%TYPE,
        total_perf  NUMBER
    );

    TYPE emp_perf_tab IS TABLE OF emp_perf_rec;
    l_emp_perf emp_perf_tab;
BEGIN
    -- 1️⃣ Bulk collect aggregated sales into collection
    SELECT e.deptno,
           s.empno,
           s.sale_date,
           SUM(s.sales_amount) AS total_sales
    BULK COLLECT INTO l_perf
    FROM   emp e
           JOIN sales s ON e.empno = s.empno
           JOIN dept d  ON e.deptno = d.deptno
    GROUP  BY e.deptno, s.empno, s.sale_date;

    -- 2️⃣ Insert into PERFORMANCE in chunks of 10,000 rows
    FOR i IN 1 .. CEIL(l_perf.COUNT / 10000) LOOP
        FORALL j IN ((i-1)*10000 + 1) .. LEAST(i*10000, l_perf.COUNT)
            INSERT INTO performance (deptno, empno, sale_date, total_sales)
            VALUES (l_perf(j).deptno,
                    l_perf(j).empno,
                    l_perf(j).sale_date,
                    l_perf(j).total_sales);

        COMMIT; -- commit after each chunk
    END LOOP;

    -- 3️⃣ Collect total performance per employee for EMP update
    SELECT empno, SUM(total_sales) AS total_perf
    BULK COLLECT INTO l_emp_perf
    FROM performance
    GROUP BY empno;

    -- 4️⃣ Bulk update EMP.performance
    FORALL i IN 1 .. l_emp_perf.COUNT
        UPDATE emp
        SET performance = l_emp_perf(i).total_perf
        WHERE empno = l_emp_perf(i).empno;

    COMMIT; -- final commit after updating EMP
END load_and_update_performance;



INSERT /*+ APPEND */ INTO performance (deptno, empno, sale_date, total_sales)
SELECT e.deptno,
       s.empno,
       s.sale_date,
       SUM(s.sales_amount)
FROM   emp e
       JOIN sales s ON e.empno = s.empno
GROUP  BY e.deptno, s.empno, s.sale_date;




DECLARE
    CURSOR c_data IS
        SELECT e.deptno, s.empno, s.sale_date, SUM(s.sales_amount) AS total_sales
        FROM emp e
             JOIN sales s ON e.empno = s.empno
        GROUP BY e.deptno, s.empno, s.sale_date;
    TYPE perf_tab IS TABLE OF performance%ROWTYPE;
    l_data perf_tab;
BEGIN
    OPEN c_data;
    LOOP
        FETCH c_data BULK COLLECT INTO l_data LIMIT 10000;  -- fetch 10k at a time
        EXIT WHEN l_data.COUNT = 0;

        FORALL i IN 1 .. l_data.COUNT
            INSERT INTO performance (deptno, empno, sale_date, total_sales)
            VALUES (l_data(i).deptno, l_data(i).empno, l_data(i).sale_date, l_data(i).total_sales);

        COMMIT;  -- commit after each chunk
    END LOOP;
    CLOSE c_data;
END;


UPDATE (
    SELECT t1.column1, t1.column2, t2.new_column1, t2.new_column2
    FROM your_table t1
    JOIN another_table t2
      ON t1.id = t2.id
     AND t2.some_condition
) v
SET v.column1 = v.new_column1,
    v.column2 = v.new_column2;




























WITH
-- 1) combos
combos AS (
    SELECT DISTINCT location_id, item_id, shop_id
    FROM (
        SELECT location_id, item_id, shop_id FROM inventory_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM delivery_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM sales_table
    )
),
-- 2) calendar dates
dates AS (
    SELECT date_seq, date_key, day_of_week, date_week, year_of_day
    FROM date_table
    WHERE date_seq BETWEEN DATE '2025-07-31' AND DATE '2025-10-31'
),
-- 3) full calendar per combo
calendar AS (
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           d.date_seq,
           d.date_key,
           d.day_of_week,
           TRUNC(d.date_seq, 'IW') AS week_monday
    FROM combos c
    CROSS JOIN dates d
),
-- 4) aggregates on source tables
inv_agg AS (
    SELECT location_id, item_id, shop_id, inventory_date, SUM(inventory_qty) AS inventory_qty
    FROM inventory_table
    GROUP BY location_id, item_id, shop_id, inventory_date
),
del_agg AS (
    SELECT location_id, item_id, shop_id, delivery_date, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id, shop_id, delivery_date
),
sal_agg AS (
    SELECT location_id, item_id, shop_id, sales_date, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id, shop_id, sales_date
),
-- 5) daily rows w/ running inventory (inventory = running sum of inv + del - sales)
daily_data AS (
    SELECT
        cal.location_id,
        cal.item_id,
        cal.shop_id,
        cal.date_seq,
        cal.date_key,
        cal.day_of_week,
        -- running balance (end-of-day inventory)
        SUM(NVL(inv.inventory_qty,0) + NVL(del.delivery_qty,0) - NVL(sal.sales_qty,0))
          OVER (PARTITION BY cal.location_id, cal.item_id, cal.shop_id
                ORDER BY cal.date_seq
                ROWS UNBOUNDED PRECEDING) AS inventory_qty,
        NVL(del.delivery_qty,0) AS delivery_qty,
        NVL(sal.sales_qty,0)    AS sales_qty,
        (NVL(del.delivery_qty,0) - NVL(sal.sales_qty,0)) AS day_result,
        cal.week_monday
    FROM calendar cal
    LEFT JOIN inv_agg inv
      ON cal.location_id = inv.location_id
     AND cal.item_id     = inv.item_id
     AND cal.shop_id     = inv.shop_id
     AND cal.date_seq    = inv.inventory_date
    LEFT JOIN del_agg del
      ON cal.location_id = del.location_id
     AND cal.item_id     = del.item_id
     AND cal.shop_id     = del.shop_id
     AND cal.date_seq    = del.delivery_date
    LEFT JOIN sal_agg sal
      ON cal.location_id = sal.location_id
     AND cal.item_id     = sal.item_id
     AND cal.shop_id     = sal.shop_id
     AND cal.date_seq    = sal.sales_date
),
-- 6) weekly totals (one row per week per combo). inventory = Sunday snapshot (end-of-week),
-- flows = weekly sums; weekdays_with_data used to decide whether to emit weekly total.
weekly_agg AS (
    SELECT
        location_id,
        item_id,
        shop_id,
        week_monday,
        week_monday + 6 AS week_sunday,
        -- Sunday snapshot for inventory (end-of-week)
        MAX(CASE WHEN date_seq = week_monday + 6 THEN inventory_qty END) AS week_inventory,
        -- weekly flows
        SUM(delivery_qty) AS week_delivery,
        SUM(sales_qty)    AS week_sales,
        -- how many Mon-Sat rows had any data (useful to decide whether to show weekly total)
        SUM(CASE WHEN (date_seq - week_monday + 1) BETWEEN 1 AND 6
                 AND (NVL(inventory_qty,0) <> 0 OR NVL(delivery_qty,0) <> 0 OR NVL(sales_qty,0) <> 0)
             THEN 1 ELSE 0 END) AS weekdays_with_data
    FROM daily_data
    GROUP BY location_id, item_id, shop_id, week_monday
),
-- 7) compute forward-4-week averages only on weekly_agg using ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING.
--    This ensures the window moves by weekly rows, not by date range (avoids the daily-row problem).
weekly_with_avg AS (
    SELECT
        w.*,
        AVG(week_inventory) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS avg_inv_next4,
        AVG(week_delivery) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS avg_del_next4,
        AVG(week_sales) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS avg_sales_next4,
        COUNT(*) OVER (
            PARTITION BY location_id, item_id, shop_id
            ORDER BY week_monday
            ROWS BETWEEN 1 FOLLOWING AND 4 FOLLOWING
        ) AS weeks_ahead_count
    FROM weekly_agg w
),
-- 8) combined: daily rows + weekly rows (weekly rows pulled from weekly_with_avg; we only emit weekly rows where weekdays_with_data > 0)
combined AS (
    -- daily detail rows (no 4-week averages)
    SELECT
        location_id,
        item_id,
        shop_id,
        date_seq,
        date_key,
        day_of_week,
        inventory_qty,
        delivery_qty,
        sales_qty,
        day_result,
        NULL AS weekly_total_flag,
        week_monday,
        (date_seq - week_monday + 1) AS day_pos,
        NULL         AS inventory_qty_4_weeks,
        NULL         AS delivery_qty_4_weeks,
        NULL         AS sales_qty_4_weeks
    FROM daily_data
    UNION ALL
    -- weekly total rows, with forward-4-week averages populated only when at least 4 weeks exist ahead
    SELECT
        w.location_id,
        w.item_id,
        w.shop_id,
        w.week_sunday   AS date_seq,
        TO_CHAR(w.week_sunday,'YYYYMMDD') AS date_key,
        'Weekly Total'  AS day_of_week,
        w.week_inventory AS inventory_qty,
        w.week_delivery  AS delivery_qty,
        w.week_sales     AS sales_qty,
        NULL             AS day_result,
        'Y'              AS weekly_total_flag,
        w.week_monday,
        8                AS day_pos,
        CASE WHEN w.weeks_ahead_count >= 4 THEN w.avg_inv_next4 ELSE NULL END AS inventory_qty_4_weeks,
        CASE WHEN w.weeks_ahead_count >= 4 THEN w.avg_del_next4 ELSE NULL END AS delivery_qty_4_weeks,
        CASE WHEN w.weeks_ahead_count >= 4 THEN w.avg_sales_next4 ELSE NULL END AS sales_qty_4_weeks
    FROM weekly_with_avg w
    WHERE w.weekdays_with_data > 0
)
-- final output ordered so weekly total appears after Sunday
SELECT *
FROM combined
ORDER BY location_id, item_id, shop_id, week_monday, day_pos, date_seq;












WITH
-- 1) combos of shop/location/item
combos AS (
    SELECT DISTINCT location_id, item_id, shop_id
    FROM (
        SELECT location_id, item_id, shop_id FROM delivery_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM sales_table
    )
),
-- 2) calendar dates
dates AS (
    SELECT date_seq
    FROM date_table
    WHERE date_seq BETWEEN DATE '2025-08-01' AND DATE '2025-09-01'
),
-- 3) full calendar per combo
calendar AS (
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           d.date_seq
    FROM combos c
    CROSS JOIN dates d
),
-- 4) aggregate deliveries
del_agg AS (
    SELECT location_id, item_id, shop_id, delivery_date, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id, shop_id, delivery_date
),
-- 5) aggregate sales
sal_agg AS (
    SELECT location_id, item_id, shop_id, sales_date, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id, shop_id, sales_date
),
-- 6) daily data with NVL
daily_data AS (
    SELECT
        cal.location_id,
        cal.item_id,
        cal.shop_id,
        cal.date_seq,
        NVL(del.delivery_qty, 0) AS delivery_qty,
        NVL(sal.sales_qty, 0)    AS sales_qty
    FROM calendar cal
    LEFT JOIN del_agg del
      ON cal.location_id = del.location_id
     AND cal.item_id     = del.item_id
     AND cal.shop_id     = del.shop_id
     AND cal.date_seq    = del.delivery_date
    LEFT JOIN sal_agg sal
      ON cal.location_id = sal.location_id
     AND cal.item_id     = sal.item_id
     AND cal.shop_id     = sal.shop_id
     AND cal.date_seq    = sal.sales_date
),
-- 7) rolling 28-day averages
rolling AS (
    SELECT
        d.location_id,
        d.item_id,
        d.shop_id,
        d.date_seq,
        d.delivery_qty,
        d.sales_qty,
        SUM(d.delivery_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_delivery_28d,
        SUM(d.sales_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_sales_28d,
        COUNT(*) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS cnt_28d
    FROM daily_data d
),
-- 8) average past 28 days
avg_data AS (
    SELECT
        r.*,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_delivery_28d / r.cnt_28d ELSE 0 END AS avg_delivery_28d,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_sales_28d / r.cnt_28d ELSE 0 END AS avg_sales_28d
    FROM rolling r
),
-- 9) total per location/item/date
totals AS (
    SELECT
        a.date_seq,
        a.location_id,
        a.item_id,
        SUM(a.delivery_qty) AS total_delivery_qty,
        SUM(a.avg_delivery_28d) AS total_avg_delivery_28d,
        SUM(a.avg_sales_28d) AS total_avg_sales_28d
    FROM avg_data a
    GROUP BY a.date_seq, a.location_id, a.item_id
),
-- 10) join to compute proportions and initial fixed allocation
proportions AS (
    SELECT
        a.location_id,
        a.item_id,
        a.shop_id,
        a.date_seq,
        a.delivery_qty,
        a.sales_qty,
        a.avg_delivery_28d,
        a.avg_sales_28d,
        t.total_delivery_qty,
        t.total_avg_delivery_28d,
        t.total_avg_sales_28d,
        CASE WHEN t.total_avg_delivery_28d = 0 THEN 0
             ELSE round(a.avg_delivery_28d / t.total_avg_delivery_28d, 4) END AS avg_delivery_28d_proportion,
        CASE WHEN t.total_avg_sales_28d = 0 THEN 0
             ELSE round(a.avg_sales_28d / t.total_avg_sales_28d, 4) END AS avg_sales_28d_proportion,
        ROUND(t.total_delivery_qty *
             CASE WHEN t.total_avg_delivery_28d = 0 THEN 1.0 / COUNT(*) OVER (PARTITION BY a.location_id, a.item_id, a.date_seq)
                  ELSE a.avg_delivery_28d / t.total_avg_delivery_28d END
        ) AS fixed_delivery_qty_base
    FROM avg_data a
    JOIN totals t
      ON a.location_id = t.location_id
     AND a.item_id     = t.item_id
     AND a.date_seq    = t.date_seq
),
-- 11) adjust rounding differences
adjusted AS (
    SELECT
        p.*,
        SUM(p.fixed_delivery_qty_base) OVER (PARTITION BY p.location_id, p.item_id, p.date_seq) AS sum_fixed_base,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion DESC) AS rn_desc,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion ASC) AS rn_asc
    FROM proportions p
)
-- 12) final fixed delivery qty with adjustment
SELECT
    a.location_id,
    a.item_id,
    a.shop_id,
    a.date_seq,
    a.delivery_qty,
    a.sales_qty,
    a.avg_delivery_28d,
    a.avg_sales_28d,
    a.avg_delivery_28d_proportion,
    a.avg_sales_28d_proportion,
    a.total_delivery_qty,
    a.sum_fixed_base,
    a.fixed_delivery_qty_base,
CASE
    WHEN a.total_delivery_qty = a.sum_fixed_base THEN a.fixed_delivery_qty_base
    WHEN a.total_delivery_qty > a.sum_fixed_base AND a.rn_desc = 1 THEN a.fixed_delivery_qty_base + (a.total_delivery_qty - a.sum_fixed_base)
    WHEN a.total_delivery_qty < a.sum_fixed_base AND a.rn_asc = 1 THEN a.fixed_delivery_qty_base - (a.sum_fixed_base - a.total_delivery_qty)
    ELSE a.fixed_delivery_qty_base
END AS fixed_delivery_qty
FROM adjusted a
ORDER BY a.location_id, a.item_id, a.shop_id, a.date_seq;






WITH
-- 1) combos of shop/location/item
combos AS (
    SELECT DISTINCT location_id, item_id, shop_id
    FROM (
        SELECT location_id, item_id, shop_id FROM delivery_table
        UNION ALL
        SELECT location_id, item_id, shop_id FROM sales_table
    ) t
),
-- 2) calendar dates
dates AS (
    SELECT date_seq
    FROM date_table
    WHERE date_seq BETWEEN DATE '2025-08-01' AND DATE '2025-09-01'
),
-- 3) full calendar per combo
calendar AS (
    SELECT c.location_id,
           c.item_id,
           c.shop_id,
           d.date_seq
    FROM combos c
    CROSS JOIN dates d
),
-- 4) aggregate deliveries
del_agg AS (
    SELECT location_id, item_id, shop_id, delivery_date, SUM(delivery_qty) AS delivery_qty
    FROM delivery_table
    GROUP BY location_id, item_id, shop_id, delivery_date
),
-- 5) aggregate sales
sal_agg AS (
    SELECT location_id, item_id, shop_id, sales_date, SUM(sales_qty) AS sales_qty
    FROM sales_table
    GROUP BY location_id, item_id, shop_id, sales_date
),
-- 6) daily data with NVL
daily_data AS (
    SELECT
        cal.location_id,
        cal.item_id,
        cal.shop_id,
        cal.date_seq,
        NVL(del.delivery_qty, 0) AS delivery_qty,
        NVL(sal.sales_qty, 0) AS sales_qty
    FROM calendar cal
    LEFT JOIN del_agg del
      ON cal.location_id = del.location_id
     AND cal.item_id = del.item_id
     AND cal.shop_id = del.shop_id
     AND cal.date_seq = del.delivery_date
    LEFT JOIN sal_agg sal
      ON cal.location_id = sal.location_id
     AND cal.item_id = sal.item_id
     AND cal.shop_id = sal.shop_id
     AND cal.date_seq = sal.sales_date
),
-- 7) rolling 28-day sums and counts (efficient analytic calculation)
rolling AS (
    SELECT
        d.location_id,
        d.item_id,
        d.shop_id,
        d.date_seq,
        d.delivery_qty,
        d.sales_qty,
        SUM(d.delivery_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_delivery_28d,
        SUM(d.sales_qty) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS sum_sales_28d,
        COUNT(*) OVER (
            PARTITION BY d.location_id, d.item_id, d.shop_id
            ORDER BY d.date_seq
            ROWS BETWEEN 28 PRECEDING AND 1 PRECEDING
        ) AS cnt_28d
    FROM daily_data d
),
-- 8) average past 28 days
avg_data AS (
    SELECT
        r.location_id,
        r.item_id,
        r.shop_id,
        r.date_seq,
        r.delivery_qty,
        r.sales_qty,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_delivery_28d / r.cnt_28d ELSE 0 END AS avg_delivery_28d,
        CASE WHEN r.cnt_28d > 0 THEN r.sum_sales_28d / r.cnt_28d ELSE 0 END AS avg_sales_28d
    FROM rolling r
),
-- 9) total per location/item/date
totals AS (
    SELECT
        a.date_seq,
        a.location_id,
        a.item_id,
        SUM(a.delivery_qty) AS total_delivery_qty,
        SUM(a.avg_delivery_28d) AS total_avg_delivery_28d,
        SUM(a.avg_sales_28d) AS total_avg_sales_28d
    FROM avg_data a
    GROUP BY a.date_seq, a.location_id, a.item_id
),
-- 10) join to compute proportions and initial fixed allocation
proportions AS (
    SELECT
        a.location_id,
        a.item_id,
        a.shop_id,
        a.date_seq,
        a.delivery_qty,
        a.sales_qty,
        a.avg_delivery_28d,
        a.avg_sales_28d,
        t.total_delivery_qty,
        t.total_avg_delivery_28d,
        t.total_avg_sales_28d,
        CASE WHEN t.total_avg_delivery_28d = 0 THEN 0
             ELSE round(a.avg_delivery_28d / t.total_avg_delivery_28d, 4) END AS avg_delivery_28d_proportion,
        CASE WHEN t.total_avg_sales_28d = 0 THEN 0
             ELSE round(a.avg_sales_28d / t.total_avg_sales_28d, 4) END AS avg_sales_28d_proportion,
        ROUND(t.total_delivery_qty *
             CASE WHEN t.total_avg_delivery_28d = 0 THEN 1.0 / COUNT(*) OVER (PARTITION BY a.location_id, a.item_id, a.date_seq)
                  ELSE a.avg_delivery_28d / t.total_avg_delivery_28d END
        ) AS fixed_delivery_qty_base
    FROM avg_data a
    JOIN totals t
      ON a.location_id = t.location_id
     AND a.item_id = t.item_id
     AND a.date_seq = t.date_seq
),
-- 11) adjust rounding differences
adjusted AS (
    SELECT
        p.*,
        SUM(p.fixed_delivery_qty_base) OVER (PARTITION BY p.location_id, p.item_id, p.date_seq) AS sum_fixed_base,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion DESC) AS rn_desc,
        ROW_NUMBER() OVER (PARTITION BY p.location_id, p.item_id, p.date_seq ORDER BY p.avg_delivery_28d_proportion ASC) AS rn_asc
    FROM proportions p
)
-- 12) final fixed delivery qty with adjustment
SELECT
    a.location_id,
    a.item_id,
    a.shop_id,
    a.date_seq,
    a.delivery_qty,
    a.sales_qty,
    a.avg_delivery_28d,
    a.avg_sales_28d,
    a.avg_delivery_28d_proportion,
    a.avg_sales_28d_proportion,
    a.total_delivery_qty,
    a.sum_fixed_base,
    a.fixed_delivery_qty_base,
    CASE
        WHEN a.total_delivery_qty = a.sum_fixed_base THEN a.fixed_delivery_qty_base
        WHEN a.total_delivery_qty > a.sum_fixed_base AND a.rn_desc = 1 THEN a.fixed_delivery_qty_base + (a.total_delivery_qty - a.sum_fixed_base)
        WHEN a.total_delivery_qty < a.sum_fixed_base AND a.rn_asc = 1 THEN a.fixed_delivery_qty_base - (a.sum_fixed_base - a.total_delivery_qty)
        ELSE a.fixed_delivery_qty_base
    END AS fixed_delivery_qty
FROM adjusted a
ORDER BY a.location_id, a.item_id, a.shop_id, a.date_seq;























WITH
-- 1) sales per shop on given day
day_sum_result AS (
    SELECT LOCATION_ID, ITEM_ID, SHOP_ID, SUM(SALES_QTY) AS DAY_SUM_QTY
    FROM SALES_TABLE
    WHERE SALES_DATE = DATE '2025-08-08'
      AND ITEM_ID = 'MacBook'
    GROUP BY LOCATION_ID, ITEM_ID, SHOP_ID
),
-- 2) total sales per item/location
shop_sum_result AS (
    SELECT LOCATION_ID, ITEM_ID, SHOP_ID, DAY_SUM_QTY,
           SUM(DAY_SUM_QTY) OVER (PARTITION BY LOCATION_ID, ITEM_ID) AS shop_sum_qty
    FROM day_sum_result
),
-- 3) ratio per shop
shop_ratio AS (
    SELECT a.ITEM_ID, a.SHOP_ID,
           ROUND(SUM(a.DAY_SUM_QTY) / SUM(a.SHOP_SUM_QTY), 4) AS ratio
    FROM shop_sum_result a
    GROUP BY a.ITEM_ID, a.SHOP_ID
),
-- 4) join with deliveries and compute base allocations
base_rows AS (
    SELECT A.LOCATION_ID,
           A.ITEM_ID,
           A.SHOP_ID,
           A.DELIVERY_QTY,
           B.RATIO,
           SUM(A.DELIVERY_QTY) OVER (PARTITION BY A.LOCATION_ID, A.ITEM_ID) AS total_delivery_qty,
           ROUND(SUM(A.DELIVERY_QTY) OVER (PARTITION BY A.LOCATION_ID, A.ITEM_ID) * B.RATIO, 0) AS delivery_ratio_qty
    FROM DELIVERY_TABLE A
    JOIN shop_ratio B
      ON A.SHOP_ID = B.SHOP_ID
    WHERE A.DELIVERY_DATE = DATE '2025-08-08'
      AND A.LOCATION_ID = 'loc01'
),
-- 5) compute total vs sum_base
totals AS (
    SELECT location_id, item_id,
           SUM(delivery_ratio_qty) AS sum_fixed_base,
           MAX(total_delivery_qty)  AS total_delivery_qty
    FROM base_rows
    GROUP BY location_id, item_id
),
-- 6) add row numbers for allocation order
ranked AS (
    SELECT b.location_id,
           b.item_id,
           b.shop_id,
           b.delivery_qty,
           b.ratio,
           b.total_delivery_qty AS base_total_delivery_qty,
           b.delivery_ratio_qty,
           t.sum_fixed_base,
           t.total_delivery_qty AS total_delivery_qty,  -- canonical
           ROW_NUMBER() OVER (PARTITION BY b.location_id, b.item_id ORDER BY b.ratio ASC)  AS rn_asc,
           ROW_NUMBER() OVER (PARTITION BY b.location_id, b.item_id ORDER BY b.ratio DESC) AS rn_desc
    FROM base_rows b
    JOIN totals t
      ON b.location_id = t.location_id
     AND b.item_id     = t.item_id
),
-- 7) recursive redistribution of negative difference (only if sum_fixed_base > total_delivery_qty)
adjust_cte (location_id, item_id, shop_id, rn_asc, delivery_ratio_qty, remaining_diff, fixed_qty) AS (
    -- Anchor: smallest ratio (rn_asc = 1)
    SELECT r.location_id,
           r.item_id,
           r.shop_id,
           r.rn_asc,
           r.delivery_ratio_qty,
           (r.sum_fixed_base - r.total_delivery_qty) AS remaining_diff,
           CASE
             WHEN r.delivery_ratio_qty >= (r.sum_fixed_base - r.total_delivery_qty)
             THEN r.delivery_ratio_qty - (r.sum_fixed_base - r.total_delivery_qty)
             ELSE 0
           END AS fixed_qty
    FROM ranked r
    WHERE r.rn_asc = 1
      AND r.sum_fixed_base > r.total_delivery_qty
    UNION ALL
    -- Recursive: next rows absorb the leftover
    SELECT r.location_id,
           r.item_id,
           r.shop_id,
           r.rn_asc,
           r.delivery_ratio_qty,
           GREATEST(a.remaining_diff - r.delivery_ratio_qty, 0) AS remaining_diff,
           CASE
             WHEN a.remaining_diff <= r.delivery_ratio_qty
             THEN r.delivery_ratio_qty - a.remaining_diff
             ELSE 0
           END AS fixed_qty
    FROM ranked r
    JOIN adjust_cte a
      ON r.location_id = a.location_id
     AND r.item_id     = a.item_id
     AND r.rn_asc      = a.rn_asc + 1
)
-- 8) final result
SELECT r.location_id,
       r.item_id,
       r.shop_id,
       r.delivery_qty,
       r.delivery_ratio_qty,
       r.base_total_delivery_qty,
       r.sum_fixed_base,
       CASE
         -- Case 1: sum_fixed_base > total_delivery_qty → use recursive adjusted qty
         WHEN r.sum_fixed_base > r.total_delivery_qty
         THEN COALESCE(a.fixed_qty, r.delivery_ratio_qty)
         -- Case 2: sum_fixed_base < total_delivery_qty → add difference to highest ratio shop
         WHEN r.sum_fixed_base < r.total_delivery_qty AND r.rn_desc = 1
         THEN r.delivery_ratio_qty + (r.total_delivery_qty - r.sum_fixed_base)
         ELSE r.delivery_ratio_qty
       END AS fixed_delivery_qty
FROM ranked r
LEFT JOIN adjust_cte a
  ON r.location_id = a.location_id
 AND r.item_id     = a.item_id
 AND r.shop_id     = a.shop_id
ORDER BY r.location_id, r.item_id, r.rn_asc;




















WITH
day_sum_result AS (
SELECT
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID,
	SUM(SALES_QTY) AS DAY_SUM_QTY
FROM
	SALES_TABLE
WHERE
	SALES_DATE = DATE '2025-08-08'
	AND ITEM_ID = 'MacBook'
GROUP BY
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID
),
shop_sum_result AS (
SELECT
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID,
	DAY_SUM_QTY,
	SUM(DAY_SUM_QTY) OVER (PARTITION BY LOCATION_ID,
	ITEM_ID) AS shop_sum_qty
FROM
	day_sum_result
ORDER BY
	LOCATION_ID,
	ITEM_ID,
	SHOP_ID
),
shop_ratio AS (
SELECT
	a.ITEM_ID,
	a.SHOP_ID,
	round(sum(a.DAY_SUM_QTY) / sum(a.SHOP_SUM_QTY), 2) AS ratio
FROM
	shop_sum_result a
GROUP BY
	a.ITEM_ID,
	a.SHOP_ID
),
ranked AS (
SELECT
	p.*,
	SUM(p.delivery_ratio_qty + 50) OVER (PARTITION BY p.location_id,
	p.item_id) AS sum_fixed_base,
	ROW_NUMBER() OVER (PARTITION BY p.location_id,
	p.item_id
ORDER BY
	p.RATIO DESC) AS rn_desc,
	ROW_NUMBER() OVER (PARTITION BY p.location_id,
	p.item_id
ORDER BY
	p.RATIO ASC) AS rn_asc
FROM
	(
	SELECT
		A.*,
		B.RATIO,
		sum(A.delivery_qty) OVER (PARTITION BY a.location_id,
		b.item_id) AS total_delivery_qty,
		round(sum(A.delivery_qty) OVER (PARTITION BY a.location_id, b.item_id) * b.RATIO, 0) AS delivery_ratio_qty
	FROM
		DELIVERY_TABLE A,
		shop_ratio B
	WHERE
		A.SHOP_ID = B.SHOP_ID
		AND A.DELIVERY_DATE = DATE '2025-08-08'
		AND A.LOCATION_ID = 'loc01'
) p
),
adjust_cte (location_id,
item_id,
shop_id,
rn_asc,
tag,
SUM_FIXED_BASE,
TOTAL_DELIVERY_QTY,
delivery_ratio_qty,
remaining,
remaining_diff,
fixed_qt) AS (
SELECT
	r.LOCATION_ID,
	r.ITEM_ID,
	r.SHOP_ID,
	r.RN_ASC,
	'a' AS tag,
	r.SUM_FIXED_BASE,
	r.TOTAL_DELIVERY_QTY,
	r.DELIVERY_RATIO_QTY,
	r.remaining_diff AS remaining,
	r.remaining_diff - (DELIVERY_RATIO_QTY - fixed_qty) AS remaining_diff,
	r.fixed_qty
FROM
	(
	SELECT
		r.LOCATION_ID,
		r.ITEM_ID,
		r.SHOP_ID,
		r.RN_ASC,
		'a' AS tag,
		r.SUM_FIXED_BASE,
		r.TOTAL_DELIVERY_QTY,
		r.DELIVERY_RATIO_QTY,
		r.SUM_FIXED_BASE - r.TOTAL_DELIVERY_QTY AS remaining_diff,
		CASE
			WHEN r.DELIVERY_RATIO_QTY >= (r.sum_fixed_base - total_delivery_qty)
     THEN r.DELIVERY_RATIO_QTY - (r.sum_fixed_base - total_delivery_qty)
			ELSE 0
		END AS fixed_qty
	FROM
		ranked r
	WHERE
		r.RN_ASC = 1
		AND r.SUM_FIXED_BASE > r.TOTAL_DELIVERY_QTY
) r
UNION ALL
SELECT
	r.LOCATION_ID,
	r.ITEM_ID,
	r.SHOP_ID,
	r.RN_ASC,
	'b' AS tag,
	r.SUM_FIXED_BASE,
	r.TOTAL_DELIVERY_QTY,
	r.DELIVERY_RATIO_QTY,
	a.remaining,
	greatest (a.REMAINING_DIFF - r.DELIVERY_RATIO_QTY,
	0) AS remaining_diff,
	CASE
		WHEN a.REMAINING_DIFF <= r.DELIVERY_RATIO_QTY
     THEN r.DELIVERY_RATIO_QTY - a.REMAINING_DIFF
		ELSE 0
	END AS fixed_qty
FROM
	ranked r,
	adjust_cte a
WHERE
	r.LOCATION_ID = a.LOCATION_ID
	AND r.ITEM_ID = a.ITEM_ID
	AND r.RN_ASC = a.RN_ASC + 1
)
SELECT
	*
FROM
	adjust_cte
WHERE
	ITEM_ID = 'MacBook'



SELECT A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, A.DATE_SEQ, A.DAY_OF_WEEK,
       A.INVENTORY_QTY, B.DELIVERY_QTY, C.SALES_QTY,
       NVL(B.DELIVERY_QTY, 0) - NVL(C.SALES_QTY, 0) AS DAY_RESULT,
       SUM(NVL(A.INVENTORY_QTY, 0) + NVL(B.DELIVERY_QTY, 0) - NVL(C.SALES_QTY, 0)) OVER (PARTITION BY A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID ORDER BY A.DATE_SEQ) AS INVENTORY
FROM (
      SELECT *
      FROM DATE_TABLE A
           LEFT OUTER JOIN INVENTORY_TABLE B PARTITION BY (B.LOCATION_ID, B.ITEM_ID, B.SHOP_ID)
           ON A.DATE_SEQ = B.INVENTORY_DATE
      WHERE A.DATE_SEQ BETWEEN DATE '2025-07-31' AND DATE '2025-10-31'
      ) A,
      DELIVERY_TABLE B,
      SALES_TABLE C
WHERE A.DATE_SEQ = B.DELIVERY_DATE (+)
AND A.LOCATION_ID = B.LOCATION_ID (+)
AND A.ITEM_ID = B.ITEM_ID (+)
AND A.SHOP_ID = B.SHOP_ID (+)
AND A.DATE_SEQ = C.SALES_DATE (+)
AND A.LOCATION_ID = C.LOCATION_ID (+)
AND A.ITEM_ID = C.ITEM_ID (+)
AND A.SHOP_ID = C.SHOP_ID (+)
ORDER BY A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, A.DATE_SEQ


SELECT A.*, SUM(INVENTORY_QTY) OVER (ORDER BY A.SALES_DATE)
FROM (
SELECT A.INVENTORY_DATE AS SALES_DATE, A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, 0 AS SALES_QTY, 0 AS DELIVERY_QTY, A.INVENTORY_QTY 
FROM INVENTORY_TABLE A
WHERE A.LOCATION_ID = 'loc01'
AND A.ITEM_ID = 'iPhone'
AND A.SHOP_ID = 'Costco'
UNION all
SELECT A.SALES_DATE, A.LOCATION_ID, A.ITEM_ID, A.SHOP_ID, A.SALES_QTY, B.DELIVERY_QTY, B.DELIVERY_QTY - A.SALES_QTY AS INVENTORY_QTY
FROM SALES_TABLE A, DELIVERY_TABLE B
WHERE A.LOCATION_ID = B.LOCATION_ID
AND A.ITEM_ID = B.ITEM_ID
AND A.SHOP_ID = B.SHOP_ID
AND A.SALES_DATE = B.DELIVERY_DATE
AND A.LOCATION_ID = 'loc01'
AND A.ITEM_ID = 'iPhone'
AND A.SHOP_ID = 'Costco'
) A
--ORDER BY A.SALES_DATE
